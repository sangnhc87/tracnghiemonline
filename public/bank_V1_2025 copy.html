<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Ng√¢n H√†ng Latex C·ª•c B·ªô</title> <!-- MODIFICATION: Updated title -->
    <base target="_top">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <!-- SweetAlert2 CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <style>
        /* --- General Styles --- */
        body { padding-bottom: 100px; font-size: 0.95rem; }
        ul { list-style-type: none; padding-left: 18px; margin-bottom: 0.15rem; }
        li { margin: 1px 0; }
        .hidden { display: none !important; }
        .highlight { background-color: #fff3cd; padding: 0 2px; border-radius: 2px; }
         /* MODIFICATION: Highlight style for file content modal */
        #fileContentModalPre .highlight {
            background-color: yellow;
            border-bottom: 1px solid orange;
        }
         /* MODIFICATION: Highlight style for current match in file content modal */
         #fileContentModalPre .highlight.current {
             background-color: orange;
             color: white;
             border-bottom: 1px solid red;
         }


        /* --- Sticky Controls --- */
        .sticky-controls {
            position: sticky;
            top: 0;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            padding-top: 10px;
            padding-bottom: 8px;
            z-index: 1000;
            border-bottom: 1px solid #dee2e6;
        }
        .form-check-inline { margin-right: 0.6rem; padding-left: 0; }
        .form-check-input { cursor: pointer; margin-top: 0.1em; vertical-align: middle;}
        .form-check-input:checked { background-color: #0d6efd; border-color: #0d6efd; }
        .form-check-label { user-select: none; font-size: 0.85em; margin-left: 2px; vertical-align: middle; }
        .form-control-sm { font-size: 0.8rem; padding: 0.2rem 0.4rem; height: auto;}
        .form-select-sm { font-size: 0.8rem; padding: 0.2rem 1rem 0.2rem 0.4rem; height: auto;}
         .form-label { margin-bottom: 0.2rem; font-size: 0.9em;}
         .btn-sm { font-size: 0.8rem; padding: 0.2rem 0.4rem; }

        /* --- Folder Selection Info --- */
        #folderInfo {
            font-size: 0.8em;
            color: #6c757d;
            margin-top: 5px;
        }

        /* --- Tree View Styles --- */
        #menu { margin-top: 15px; }
        /* Common styles for expandable items */
        .folder > span, .folder-node > span { cursor: pointer; font-weight: 500; display: inline-block; padding: 1px 0; user-select: none;}
        .folder > span::before, .folder-node > span::before { content: '‚ñ∂'; display: inline-block; width: 1em; margin-right: 3px; transition: transform 0.15s ease-in-out; font-size: 0.8em; vertical-align: middle; }
        .folder.open > span::before, .folder-node.open > span::before { transform: rotate(90deg); }
        .folder > ul, .folder-node > ul { display: none; }
        .folder.open > ul, .folder-node.open > ul { display: block; }

        /* ID Tree Specific Styles */
        .folder-level-0 > span { color: #6f42c1; } /* Purple */
        .folder-level-1 > span { color: #0d6efd; } /* Blue */
        .folder-level-2 > span { color: #198754; } /* Green */
        .folder-level-3 > span { color: #fd7e14; } /* Orange */
        .folder-level-4 > span { color: #dc3545; } /* Red */
        .folder > span::before { content: 'üìÅ'; } /* Default folder icon */
        .folder.open > span::before { content: 'üìÇ'; } /* Default open folder icon */


        .id-leaf { margin-bottom: 3px; }
        .id-leaf > div:first-child { cursor: pointer; text-decoration: none; color: #212529; display: flex; align-items: center; padding: 1px 0; border-bottom: 1px dotted transparent; }
        .id-leaf > div:first-child span:first-child { flex-grow: 1; color: #0d6efd; border-bottom: 1px dotted transparent; transition: border-bottom-color 0.2s; margin-right: 5px; }
        .id-leaf > div:first-child span:first-child:hover { border-bottom-color: #0a58ca; }
        .id-leaf .action-btn { margin-left: 5px; font-size: 1rem; padding: 2px 4px; }

        /* File Browser Specific Styles */
        .folder-node > span::before { content: 'üìÅ'; }
        .folder-node.open > span::before { content: 'üìÇ'; }

        .file-item { margin-bottom: 2px; }
        /* Make file item span clickable and look like a link */
        .file-item > span[data-filepath] {
             cursor: pointer;
             display: flex;
             align-items: center;
             padding: 1px 0;
             color: #212529;
        }
         .file-item > span[data-filepath]::before {
             content: 'üìÑ';
             margin-right: 5px;
             font-size: 0.9em;
             vertical-align: middle;
         }
        /* Style the file path text like a link */
        .file-item .file-path-text {
             flex-grow: 1;
             color: #0d6efd;
             text-decoration: none;
             border-bottom: 1px dotted transparent;
             transition: border-bottom-color 0.2s;
         }
        .file-item .file-path-text:hover { text-decoration: none; border-bottom-color: #0a58ca; }


        /* Styles for source file links - Still relevant for ID view */
        .source-file-info { font-size: 0.8em; color: #6c757d; margin-left: 20px; margin-top: 0px; margin-bottom: 2px; }
        .view-file-link { color: #0d6efd; text-decoration: none; cursor: pointer; }
        .view-file-link:hover { text-decoration: underline; }

        .selection-container { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 2px; margin-bottom: 5px; margin-left: 20px; }
        .qty-input { width: 65px !important; font-size: 0.8em !important; padding: 2px 4px !important; height: auto !important; text-align: center; }

        /* --- Question Content Display --- */
        .ex-content { margin-left: 20px; margin-top: 4px; padding: 8px; background: #f8f9fa; border: 1px solid #dee2e6; border-left: 3px solid #ced4da; display: none; position: relative; max-height: 600px; overflow-y: auto; }
        .ex-content.loading::before { content: 'ƒêang t·∫£i n·ªôi dung...'; display: block; padding: 10px; font-style: italic; color: #6c757d; text-align: center; }

        .ex-box, .grabbed-block { border: 1px solid #dee2e6; border-left: 3px solid #ced4da; padding: 8px; margin-bottom: 8px; position: relative; background: #fff; border-radius: 4px; overflow: hidden; padding-right: 140px; }
        .ex-box:last-child, .grabbed-block:last-child { margin-bottom: 0; }
        .ex-box pre, .grabbed-block pre, #mockResult .ex-box pre { margin: 0; padding: 0; background: none; border: none; white-space: pre-wrap; word-break: break-word; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 1rem; line-height: 1.5; }
        .choice { color: #198754; font-weight: bold; }
        .choiceTF { color: #dc3545; font-weight: bold; }
        .other { color: #0dcaf0; font-weight: bold; }
        .ex-box.ex-choice, .grabbed-block.ex-choice { border-left-color: #198754; }
        .ex-box.ex-choiceTF, .grabbed-block.ex-choiceTF { border-left-color: #dc3545; }
        .ex-box.ex-other, .grabbed-block.ex-other { border-left-color: #0dcaf0; }

        /* --- Action Buttons on Blocks --- */
        .block-actions { position: absolute; top: 8px; right: 8px; display: flex; gap: 4px; background-color: rgba(255, 255, 255, 0.9); padding: 3px; border-radius: 3px; z-index: 1; }
        .action-btn { cursor: pointer; font-size: 1.2rem; vertical-align: middle; opacity: 0.7; transition: opacity 0.2s; padding: 5px 8px; border-radius: 4px; border: 1px solid transparent; background-color: transparent; line-height: 1; display: inline-flex; align-items: center; justify-content: center; }
        .action-btn:hover { opacity: 1; background-color: #e9ecef; }
        .btn-copy { color: #0d6efd; }
        .action-btn.copied-success { color: #fff !important; background-color: #198754 !important; border-color: #198754 !important; opacity: 1 !important; }
        .action-btn.btn-get.copied-success { color: #fff !important; background-color: #198754 !important; border-color: #198754 !important; opacity: 1 !important; }
        #copyAllGrabbedBtn.copied-success { color: #fff !important; background-color: #198754 !important; border-color: #198754 !important; opacity: 1 !important; }
        .btn-get { color: #28a745; }
        .btn-edit { color: #6c757d; }
        .btn-delete { color: #dc3545; }

        /* --- Tables and Results Areas --- */
        #selectedIDsTable, #mockResult, #grabbedContentArea { margin-top: 15px; }
        #selectedIDsTable table { font-size: 0.9em; }
        #grabbedContentArea { border-top: 2px dashed #dee2e6; padding-top: 15px; }
        .grabbed-block { margin-top: 0; margin-bottom: 8px; padding: 8px; }
        .grabbed-block small { font-size: 0.8em; color: #6c757d; margin-bottom: 4px; display: block; }

         /* MODIFICATION: Duplicate Results Area */
        #duplicateResultsArea {
             margin-top: 20px;
             padding: 15px;
             border: 1px solid #ffc107; /* Warning color border */
             background-color: #fff3cd; /* Warning color background */
             border-radius: 5px;
        }
         #duplicateResultsArea h5 {
             color: #856404; /* Darker warning color */
         }
         .duplicate-group {
             margin-bottom: 15px;
             padding: 10px;
             border: 1px solid #ffeeba; /* Lighter warning color border */
             background-color: #fff;
             border-radius: 4px;
         }
         .duplicate-group-header {
             font-weight: bold;
             margin-bottom: 8px;
             cursor: pointer;
         }
         .duplicate-block-item {
             margin-bottom: 5px;
             border-bottom: 1px dotted #ccc;
             padding-bottom: 5px;
             display: flex;
             align-items: flex-start;
         }
         .duplicate-block-item:last-child {
             margin-bottom: 0;
             border-bottom: none;
             padding-bottom: 0;
         }
         .duplicate-block-item .form-check {
             margin-right: 15px;
             margin-top: 3px; /* Align checkbox vertically */
         }
          .duplicate-block-item pre {
              flex-grow: 1; /* Allow pre to take space */
              margin: 0;
              padding: 0;
              font-size: 0.85em;
              white-space: pre-wrap;
              word-break: break-word;
              max-height: 150px; /* Limit height for preview */
              overflow-y: auto;
          }
         .duplicate-group-blocks {
             display: none; /* Hidden by default */
         }
         .duplicate-group.open .duplicate-group-blocks {
             display: block;
         }
         .duplicate-actions {
             margin-top: 10px;
         }


        /* --- Modal Styles --- */
        #editModalTextArea { min-height: 300px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.9em; }
        /* Styles for file content modal */
        #fileContentModal .modal-body pre {
            max-height: 70vh; /* Limit height */
            overflow-y: auto; /* Add scroll */
            background-color: #f8f9fa; /* Light background */
            padding: 10px;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            word-break: break-all; /* Break long lines */
        }
        #fileContentModal .modal-dialog { max-width: 80%; } /* Wider modal */
        /* Style for Find controls in modal footer */
        #fileContentModal .modal-footer {
            display: flex;
            justify-content: space-between; /* Distribute items */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 10px; /* Spacing between items */
        }
        #fileContentModal .modal-footer .form-inline {
            display: flex;
            gap: 5px;
            align-items: center;
        }
         #fileContentModal .modal-footer .form-inline .form-control-sm {
             width: 150px; /* Adjust width as needed */
         }
         #fileContentModal .modal-footer .form-inline .btn-sm {
              height: calc(1.5em + 0.5rem + 2px); /* Match input height */
              display: flex; /* Align icon/text vertically */
              align-items: center;
              justify-content: center;
         }
         #fileContentModal .modal-footer .btn-group {
             display: flex;
             gap: 5px;
         }


        /* --- Loading Overlay --- */
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.7); z-index: 1050; display: flex; align-items: center; justify-content: center; }
        .loading-overlay .spinner-border { margin-right: 10px; }

    </style>
    <!-- Firebase SDK (R·∫•t quan tr·ªçng) -->
<script defer src="/__/firebase/9.10.0/firebase-app-compat.js"></script>
<script defer src="/__/firebase/9.10.0/firebase-auth-compat.js"></script>
<script defer src="/__/firebase/9.10.0/firebase-functions-compat.js"></script>
<script defer src="/__/firebase/9.10.0/firebase-storage-compat.js"></script> <!-- Th√™m SDK c·ªßa Storage -->
<script defer src="/__/firebase/init.js"></script>
</head>
<body class="container-fluid pt-3">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay d-none">
        <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
        <span id="loadingText">ƒêang x·ª≠ l√Ω...</span>
    </div>

    <!-- Sticky Controls -->
    <div class="sticky-controls">
        <!-- Row 0: Title -->
        <div class="row mb-2">
            <div class="col"><h4 class="mb-0">üå≥ Ng√¢n H√†ng Latex C·ª•c B·ªô</h4><small class="text-muted">Duy·ªát v√† so·∫°n ƒë·ªÅ t·ª´ file .tex tr√™n m√°y t√≠nh</small></div>
        </div>

        <!-- Row 1: Load Local Data & Cache Management -->
        <div class="row mb-2 align-items-center gx-2">
            
             <div class="col-md-auto">
                <button id="downloadDataBtn" class="btn btn-info btn-sm" title="T·∫£i v·ªÅ d·ªØ li·ªáu c√¢u h·ªèi ƒë√£ n·∫°p trong IndexedDB th√†nh file JSON (Kh√¥ng bao g·ªìm n·ªôi dung file ƒë·∫ßy ƒë·ªß)">üíæ Download Ng√¢n H√†ng C√¢u H·ªèi</button>
            </div>
             <div class="col-md-auto">
                <button id="uploadDataBtn" class="btn btn-secondary btn-sm" title="Ch·ªçn file JSON cache c√¢u h·ªèi ƒë√£ t·∫£i v·ªÅ tr∆∞·ªõc ƒë√≥ ƒë·ªÉ n·∫°p l·∫°i d·ªØ li·ªáu v√†o IndexedDB">‚¨ÜÔ∏è Upload Ng√¢n H√†ng C√¢u H·ªèi</button>
                 <input type="file" id="uploadFileInput" style="display: none;" accept=".json">
            </div>
            <div class="col-md-auto">
                <button id="addLocalFoldersBtn" class="btn btn-primary btn-sm" title="Ch·ªçn m·ªôt ho·∫∑c nhi·ªÅu th∆∞ m·ª•c ch·ª©a file .tex tr√™n m√°y t√≠nh ƒë·ªÉ th√™m v√†o ng√¢n h√†ng c·ª•c b·ªô. S·∫Ω b·ªè qua file b·∫Øt ƒë·∫ßu b·∫±ng 'ans' ho·∫∑c 'startwhich'.">üìÇ Th√™m Th∆∞ M·ª•c</button>
                <input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;" accept=".tex,.txt">
            </div>
             <div class="col-md-auto">
                <button id="clearLocalCacheBtn" class="btn btn-danger btn-sm" title="X√≥a to√†n b·ªô d·ªØ li·ªáu c√¢u h·ªèi V√Ä file ƒë√£ n·∫°p trong IndexedDB c·ªßa tr√¨nh duy·ªát n√†y">üóëÔ∏è X√≥a Ng√¢n H√†ng C√¢u H·ªèi</button>
            </div>
             <!-- MODIFICATION: Add Find Duplicates button -->
            <div class="col-md-auto ms-auto"><button id="findDuplicatesBtn" class="btn btn-warning btn-sm" title="T√¨m c√°c c√¢u h·ªèi (block) tr√πng l·∫∑p trong cache c·ª•c b·ªô d·ª±a tr√™n n·ªôi dung t·ª´ \begin ƒë·∫øn \loigiai">üîç T√¨m c√¢u tr√πng</button></div>
            <div class="col-md-auto">
        <button id="sync-down-btn" class="btn btn-primary btn-sm" title="Ng√¢n H√†ng C√¢u H·ªèi">
            <i class="bi bi-cloud-download-fill"></i> T·∫£i v·ªÅ t·ª´ Cloud
        </button>
    </div>
            <div class="col">
                 <div id="folderInfo" class="text-muted"> </div>
            </div>
        </div>

        <!-- Row 2: Create Exams & Replace Option -->
        <div class="row mb-2 align-items-center gx-2">
             <div class="col-md-auto"><input type="number" id="numExams" class="form-control form-control-sm" placeholder="# ƒê·ªÅ" title="S·ªë ƒë·ªÅ c·∫ßn t·∫°o" min="1" style="width: 80px;"></div>
             <div class="col-md-auto"><button id="generateExamsBtn" class="btn btn-success btn-sm w-100" title="T·∫°o c√°c ƒë·ªÅ thi t·ª´ l·ª±a ch·ªçn hi·ªán t·∫°i">üß™ T·∫°o ƒë·ªÅ</button></div>
             <div class="col-md-auto"><button id="clearSelectionsBtn" class="btn btn-warning btn-sm w-100" title="B·ªè ch·ªçn t·∫•t c·∫£ c√°c c√¢u h·ªèi ƒë√£ ch·ªçn">‚ú® B·ªè ch·ªçn</button></div>
             <div class="col-md-auto"><div class="form-check form-switch" title="T·ª± ƒë·ªông ƒë·ªïi \\begin{vd|bt} th√†nh \\begin{ex} khi t·∫°o ƒë·ªÅ"><input class="form-check-input" type="checkbox" role="switch" id="replaceVdBtCheckbox"><label class="form-check-label" for="replaceVdBtCheckbox">ƒê·ªïi vd/bt‚Üíex</label></div></div>
        </div>

        <!-- Row 3: Search, Filter, Expand/Collapse and View Mode -->
        <div class="row mb-1 align-items-center gx-2">
             <!-- View Mode Selector -->
             <div class="col-md-auto">
                 <label for="viewModeSelector" class="form-label mb-0">Ch·∫ø ƒë·ªô xem:</label>
             </div>
             <div class="col-md-3">
                 <select id="viewModeSelector" class="form-select form-select-sm">
                     <option value="id-tree">Theo ID c·∫•u tr√∫c</option>
                     <option value="file-browser">Theo File/Th∆∞ m·ª•c</option>
                 </select>
             </div>

            <div id="idViewControls" class="col d-flex align-items-center gx-2">
                 <!-- Controls for ID View (Search, Filter, Expand/Collapse) -->
                 <div class="col-md-5"><input type="text" id="searchBox" class="form-control form-control-sm" placeholder="üîç T√¨m ID, Di·ªÖn gi·∫£i, N·ªôi dung..."></div>
                 <div class="col-md-4"><select id="typeFilter" class="form-select form-select-sm"><option value="all">üìÇ T·∫•t c·∫£ lo·∫°i</option><option value="choice">üü¢ TN</option><option value="choiceTF">üî¥ ƒê/S</option><option value="other">üîµ TLN</option></select></div>
                 <div class="col-md-3"><button id="clearSearchBtn" class="btn btn-outline-secondary btn-sm w-100" title="X√≥a t√¨m ki·∫øm & hi·ªÉn th·ªã l·∫°i c√¢y">‚ú® Xo√° t√¨m</button></div>
                 <!-- <div class="col-md-auto ms-auto"><button id="expandAllBtn" class="btn btn-outline-primary btn-sm me-1">+</button><button id="collapseAllBtn" class="btn btn-outline-secondary btn-sm">-</button></div> -->
            </div>

            <div id="fileViewControls" class="col d-none align-items-center gx-2">
                <!-- Controls for File View -->
                 <div class="col"><input type="text" id="fileSearchBox" class="form-control form-control-sm" placeholder="üîç T√¨m t√™n file..."></div>
                 <div class="col-md-auto ms-auto"><button id="expandAllFilesBtn" class="btn btn-outline-primary btn-sm me-1">+</button><button id="collapseAllFilesBtn" class="btn btn-outline-secondary btn-sm">-</button></div>
            </div>
        </div>
    </div> <!-- End Sticky Controls -->

    <!-- Display Area -->
    <div id="selectedIDsTable"></div>
    <div id="duplicateResultsArea" class="mt-4 d-none">
         <h5>‚ö†Ô∏è C√¢u tr√πng l·∫∑p t√¨m th·∫•y</h5>
         <!-- Duplicate groups will be rendered here -->
         <div id="duplicateGroupsContainer"></div>
         <div id="duplicateActions" class="duplicate-actions d-none">
              <button id="deleteSelectedDuplicatesBtn" class="btn btn-danger btn-sm"><i class="bi bi-trash"></i> X√≥a c√°c c√¢u ƒë√£ ch·ªçn</button>
               <button id="closeDuplicateResultsBtn" class="btn btn-secondary btn-sm"><i class="bi bi-x-circle"></i> ƒê√≥ng k·∫øt qu·∫£</button>
         </div>
    </div>
    <div id="menu" class="mt-3" style="display: none;">
         <p id="infoMessage" class="text-muted small fst-italic mb-3 d-none"></p>
        <!-- Tree or search results or file browser will be rendered here -->
    </div>
     <div id="initialMessage" class="text-center text-muted mt-4">
        Nh·∫•n n√∫t "üìÇ Th√™m Th∆∞ M·ª•c" ƒë·ªÉ ch·ªçn th∆∞ m·ª•c ch·ª©a file .tex t·ª´ m√°y t√≠nh c·ªßa b·∫°n.
    </div>
    <div id="mockResult"></div>

    <!-- KHUNG CH·ª®A C√ÅC C√ÇU ƒê∆Ø·ª¢C "L·∫§Y" -->
    <div id="grabbedContentArea" class="mt-4 d-none">
        <h5 class="mb-3">üìù C√¢u ƒë√£ l·∫•y (ƒë·ªÉ copy to√†n b·ªô)</h5>
        <div class="d-flex gap-2 mb-3">
            <button id="clearGrabbedBtn" class="btn btn-secondary btn-sm"><i class="bi bi-trash"></i> X√≥a h·∫øt</button>
            <button id="copyAllGrabbedBtn" class="btn btn-success btn-sm"><i class="bi bi-clipboard"></i> Copy t·∫•t c·∫£</button>
        </div>
        <div id="grabbedContentBlocks"></div>
    </div>

    <!-- Modal Ch·ªânh s·ª≠a Block -->
    <div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="editModalLabel">Ch·ªânh s·ª≠a n·ªôi dung Block</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <input type="hidden" id="editModalId">
            <input type="hidden" id="editModalBlockIndex">
            <p><strong>ID:</strong> <span id="editModalDisplayId" class="fw-bold"></span></p>
            <p><small class="text-danger"><i class="bi bi-exclamation-triangle-fill"></i> L∆∞u √Ω: Thay ƒë·ªïi ƒë∆∞·ª£c l∆∞u v√†o cache c·ª•c b·ªô c·ªßa tr√¨nh duy·ªát n√†y.</small></p>
            <textarea class="form-control" id="editModalTextArea" rows="15"></textarea>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">H·ªßy</button>
            <button type="button" class="btn btn-primary btn-sm" id="saveEditBtn">L∆∞u thay ƒë·ªïi (C·ª•c b·ªô)</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal xem n·ªôi dung File -->
    <div class="modal fade" id="fileContentModal" tabindex="-1" aria-labelledby="fileContentModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-xl">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="fileContentModalLabel">N·ªôi dung File</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <p><strong id="fileContentModalPath">File path...</strong></p>
             <div class="mb-3 d-flex align-items-center gap-2">
                 <input type="text" id="fileFindInput" class="form-control form-control-sm" placeholder="T√¨m...">
                 <button id="fileFindNextBtn" class="btn btn-outline-secondary btn-sm" title="T√¨m ti·∫øp"><i class="bi bi-search"></i> T√¨m ti·∫øp <span id="fileMatchCount"></span></button>
                 <div class="vr"></div>
                 <input type="text" id="fileReplaceInput" class="form-control form-control-sm" placeholder="Thay th·∫ø b·∫±ng...">
                 <button id="fileReplaceNextBtn" class="btn btn-outline-warning btn-sm" title="Thay th·∫ø m·ª•c ƒëang ch·ªçn"><i class="bi bi-arrow-right-square"></i> Thay th·∫ø</button>
                 <button id="fileReplaceAllBtn" class="btn btn-outline-danger btn-sm" title="Thay th·∫ø t·∫•t c·∫£"><i class="bi bi-arrow-repeat"></i> Thay th·∫ø t·∫•t c·∫£</button>
             </div>
             <pre id="fileContentModalPre" contenteditable="true"></pre>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">ƒê√≥ng</button>
            <button type="button" class="btn btn-primary btn-sm" id="copyFileContentBtn"><i class="bi bi-clipboard"></i> Copy n·ªôi dung file</button>
             <button type="button" class="btn btn-success btn-sm" id="saveFileContentBtn" disabled><i class="bi bi-save"></i> L∆∞u thay ƒë·ªïi (C·ª•c b·ªô)</button>
          </div>
        </div>
      </div>
    </div>


    <script>
        // --- Global Variables ---
        let db;
        const DB_NAME = 'LatexBankDB_Local_Optimized_FileView_Browser';
        const QUESTION_STORE_NAME = 'questions';
        const FILE_STORE_NAME = 'files';
        const METADATA_STORE_NAME = 'metadata';
        const VERSION = 5;

        let rawData = {}; // Filtered ID data
        let loadedFiles = []; // File path/name data
        let totalDbQuestionCount = 0;
        let totalDbFileCount = 0;
        const EXCLUDED_FILE_PREFIXES = ['ans', 'startwhich'];

        const selectedIDs = new Map();

        let loadingOverlay;
        let loadingTextElement;
        let initialMessageDiv;
        let infoMessageDiv;
        let duplicateResultsArea; // MODIFICATION: Reference to duplicate results area
        let duplicateGroupsContainer; // MODIFICATION: Reference to duplicate groups container
        let duplicateActionsDiv; // MODIFICATION: Reference to duplicate actions div


        let globalPredefinedIdMap = {};
        let currentRenderMode = 'id-tree';
        let debouncedRenderMenu;
        let debouncedRenderFileBrowser;

        const fileContentCache = new Map();
        let fileContentModalInstance = null;

        let fileContentModalPreElement;
        let copyFileContentBtnElement;
        let saveFileContentBtnElement;
        let fileFindInput;
        let fileFindNextBtn;
        let fileReplaceInput;
        let fileReplaceNextBtn;
        let fileReplaceAllBtn;
        let fileMatchCountSpan;

        let modalCurrentFilePath = null;
        let modalOriginalFileContent = null;
        let modalSearchMatches = [];
        let modalCurrentMatchIndex = -1;


        // --- Predefined ID Map (Client-Side) ---
        async function loadPredefinedIdMap_Client() {
            console.log("Attempting to load bank.json for predefined ID map...");
            try {
                const response = await fetch('bank.json');
                if (!response.ok) {
                     if (response.status === 404) {
                          console.warn("bank.json not found (404). Proceeding without predefined map.");
                          globalPredefinedIdMap = {};
                          return;
                     }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (typeof data !== 'object' || data === null) {
                    throw new Error("bank.json content is not a valid JSON object.");
                }
                globalPredefinedIdMap = data;
                console.log(`Loaded ${Object.keys(globalPredefinedIdMap).length} ID map entries from bank.json.`);
            } catch (error) {
                console.error("Error loading bank.json:", error);
                globalPredefinedIdMap = {};
                Swal.fire('C·∫£nh b√°o T·∫£i file', `Kh√¥ng th·ªÉ t·∫£i file bank.json (${error?.message || error}). M√¥ t·∫£ ID chu·∫©n c√≥ th·ªÉ kh√¥ng hi·ªÉn th·ªã, v√† t·∫•t c·∫£ ID trong cache c·ª•c b·ªô s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã (n·∫øu xem theo ID c·∫•u tr√∫c). Vui l√≤ng ƒë·∫£m b·∫£o file bank.json n·∫±m c√πng th∆∞ m·ª•c v·ªõi file HTML n√†y.`, 'warning');
            }
        }
        function getPredefinedDescById(id) { return globalPredefinedIdMap[id] || null; }

        // --- Utility Functions ---
        function escapeHtml(str) { if (typeof str !== 'string') return ''; return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;'); }
        function escapeHtmlAttribute(str) { if (typeof str !== 'string') return ''; return str.replace(/"/g, '&quot;'); }
        function escapeHtmlExceptHighlight(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&#039;')
                      .replace(/&lt;span class="highlight"&gt;/g, '<span class="highlight">')
                      .replace(/&lt;\/span&gt;/g, '</span>')
                       .replace(/&lt;span class="highlight current"&gt;/g, '<span class="highlight current">');
        }

        function showLoading(show, message = 'ƒêang x·ª≠ l√Ω...') { if (loadingOverlay && loadingTextElement) { loadingOverlay.classList.toggle('d-none', !show); loadingTextElement.textContent = message; } else { console.warn("Loading overlay elements not found."); } }
        function escapeRegExp(string) { if (typeof string !== 'string') return ''; return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };
        function highlightText(text, searchTerms) {
            if (!text) return '';
            if (!Array.isArray(searchTerms) || searchTerms.length === 0) { return escapeHtml(text); }
            let html = escapeHtml(text);
            const sortedTerms = [...searchTerms].sort((a, b) => b.length - a.length);
            sortedTerms.forEach(term => {
                if (term && term.length > 0) {
                    const escapedTerm = escapeRegExp(term);
                    try {
                        const existingHighlightPattern = /<span class="highlight">.*?<\/span>/gi;
                        const parts = html.split(existingHighlightPattern);
                        const originalSpans = html.match(existingHighlightPattern) || [];
                        let resultHtml = "";
                        const termRegex = new RegExp(escapedTerm, 'gi');
                        for(let i = 0; i < parts.length; i++) {
                             resultHtml += parts[i].replace(termRegex, `<span class="highlight">$&</span>`);
                             if (i < originalSpans.length) { resultHtml += originalSpans[i]; }
                         }
                         html = resultHtml;
                    } catch(e) { console.error("Regex error in highlightText:", e); }
                }
            });
            return html;
        }
        function getBlockTypeClass(blockContent) { if (typeof blockContent !== 'string') return 'ex-other'; if (/\\choiceTF\b/.test(blockContent)) return 'ex-choiceTF'; if (/\\choice\b(?!TF\b)/.test(blockContent)) return 'ex-choice'; return 'ex-other'; }
        function getBlockTypeName(blockContent) { if (typeof blockContent !== 'string') return 'Kh√°c'; if (/\\choiceTF\b/.test(blockContent)) return 'ƒêS'; if (/\\choice\b(?!TF\b)/.test(blockContent)) return 'TN'; return 'TLN'; }
        function classifyEx(exList) { const stats = { choice: 0, choiceTF: 0, other: 0 }; if (!Array.isArray(exList)) return stats; exList.forEach(e => { if (typeof e !== 'string') return; if (/\\choiceTF\b/.test(e)) stats.choiceTF++; else if (/\\choice\b(?!TF\b)/.test(e)) stats.choice++; else stats.other++; }); return stats; }

        // --- Copy/Grab Functions ---
        function copyText(buttonElement) { /* ... (no changes needed) ... */
             const latexToCopy = buttonElement.dataset.latex;
             const textarea = document.createElement('textarea');
             textarea.innerHTML = latexToCopy || '';
             const unescapedText = textarea.value;
             if (!unescapedText) { Swal.fire('Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ copy', '', 'info'); return; }
             if (buttonElement.classList.contains('copied-success')) { return; }
             navigator.clipboard.writeText(unescapedText).then(() => {
                 const originalHTML = buttonElement.innerHTML;
                 buttonElement.innerHTML = '<i class="bi bi-check-lg"></i> ƒê√£ copy!';
                 buttonElement.classList.add('copied-success');
                 setTimeout(() => { if (document.body.contains(buttonElement)) { buttonElement.innerHTML = originalHTML; buttonElement.classList.remove('copied-success'); } }, 1500);
             }).catch(err => { console.error('Copy failed:', err); Swal.fire('L·ªói Copy', 'Kh√¥ng th·ªÉ copy n·ªôi dung.', 'error'); });
        }
        function grabBlockContent(buttonElement) { /* ... (no changes needed) ... */
             const textToGrab = buttonElement.dataset.latex;
             const blockId = buttonElement.dataset.id;
             const blockIndex = buttonElement.dataset.index;
             const textarea = document.createElement('textarea');
             textarea.innerHTML = textToGrab || '';
             const unescapedText = textarea.value;
             if (!unescapedText) { Swal.fire('Kh√¥ng c√≥ n·ªôi dung block', '', 'info'); return; }
             const grabbedArea = document.getElementById('grabbedContentArea');
             const blocksContainer = document.getElementById('grabbedContentBlocks');
             if (!grabbedArea || !blocksContainer) { console.error("Grabbed content area/container not found."); Swal.fire('L·ªói N·ªôi b·ªô', 'Kh√¥ng t√¨m th·∫•y khu v·ª±c l∆∞u tr·ªØ.', 'error'); return; }
             if (buttonElement.classList.contains('copied-success')) { return; }
             grabbedArea.classList.remove('d-none');
             const blockElement = document.createElement('div');
             blockElement.className = 'grabbed-block ' + getBlockTypeClass(unescapedText);
             blockElement.dataset.originalId = blockId || '';
             blockElement.dataset.originalIndex = blockIndex || '';
             const header = document.createElement('small');
             const displayIndex = !isNaN(parseInt(blockIndex)) ? parseInt(blockIndex) + 1 : 'N/A';
             header.textContent = `T·ª´ ID: ${blockId || 'N/A'} (Block ${displayIndex}) - Lo·∫°i: ${getBlockTypeName(unescapedText)}`;
             blockElement.appendChild(header);
             const pre = document.createElement('pre');
             pre.textContent = unescapedText;
             blockElement.appendChild(pre);
             blocksContainer.appendChild(blockElement);
             const originalHTML = buttonElement.innerHTML;
             buttonElement.innerHTML = '<i class="bi bi-check-lg"></i> ƒê√£ l·∫•y!';
             buttonElement.classList.add('copied-success');
              setTimeout(() => { if (document.body.contains(buttonElement)) { buttonElement.innerHTML = originalHTML; buttonElement.classList.remove('copied-success'); } }, 1500);
             blockElement.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }
        function copyAllGrabbedContent() { /* ... (no changes needed) ... */
             const blocksContainer = document.getElementById('grabbedContentBlocks');
             const buttonElement = document.getElementById('copyAllGrabbedBtn');
             if (!blocksContainer) { console.error("Grabbed content blocks container not found."); return; }
             const blocks = blocksContainer.querySelectorAll('.grabbed-block pre');
             if (blocks.length === 0) { Swal.fire('Kh√¥ng c√≥ block n√†o ƒë·ªÉ copy', '', 'info'); return; }
             if (buttonElement && buttonElement.classList.contains('copied-success')) { return; }
             const allContent = Array.from(blocks).map(block => block.textContent || '').join('\n\n% --- Next Block --- %\n\n');
             navigator.clipboard.writeText(allContent).then(() => {
                  if (buttonElement) {
                      const originalHTML = buttonElement.innerHTML;
                       buttonElement.innerHTML = '<i class="bi bi-check-lg"></i> ƒê√£ copy!';
                       buttonElement.classList.add('copied-success');
                       setTimeout(() => { if (document.body.contains(buttonElement)) { buttonElement.innerHTML = originalHTML; buttonElement.classList.remove('copied-success'); } }, 1500);
                  }
                 Swal.fire('ƒê√£ copy!', `ƒê√£ copy ${blocks.length} block v√†o clipboard.`, 'success');
             }).catch(err => { console.error('Copy all failed:', err); Swal.fire('L·ªói Copy', 'Kh√¥ng th·ªÉ copy t·∫•t c·∫£ n·ªôi dung.', 'error'); });
        }
        function clearGrabbedContent() { /* ... (no changes needed) ... */
             const grabbedArea = document.getElementById('grabbedContentArea');
             const blocksContainer = document.getElementById('grabbedContentBlocks');
             if (!blocksContainer || blocksContainer.children.length === 0) { if(grabbedArea) grabbedArea.classList.add('d-none'); return; }
             Swal.fire({ title: 'X√≥a t·∫•t c·∫£ block ƒë√£ l·∫•y?', text: "Thao t√°c n√†y kh√¥ng th·ªÉ ho√†n t√°c!", icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', cancelButtonColor: '#3085d6', confirmButtonText: 'V√¢ng, x√≥a h·∫øt!' }).then((result) => { if (result.isConfirmed) { blocksContainer.innerHTML = ''; if(grabbedArea) grabbedArea.classList.add('d-none'); Swal.fire('ƒê√£ x√≥a!', 'T·∫•t c·∫£ block ƒë√£ ƒë∆∞·ª£c x√≥a.', 'success'); } });
        }
        // --- Tree Expand/Collapse ---
        function toggleAll(open) {
             const expandBtn = currentRenderMode === 'file-browser' || currentRenderMode === 'file-search' ? document.getElementById('expandAllFilesBtn') : document.getElementById('expandAllBtn');
             const collapseBtn = currentRenderMode === 'file-browser' || currentRenderMode === 'file-search' ? document.getElementById('collapseAllFilesBtn') : document.getElementById('collapseAllBtn');

             if (currentRenderMode === 'file-browser' || currentRenderMode === 'file-search') {
                 document.querySelectorAll("#menu .folder-node").forEach(el => {
                     el.classList.toggle("open", open);
                 });
             } else {
                document.querySelectorAll("#menu .folder").forEach(el => {
                    el.classList.toggle("open", open);
                    if(open && el.dataset.loaded === 'false') {
                        const loadEvent = new Event('click', { bubbles: true });
                        el.querySelector('span')?.dispatchEvent(loadEvent);
                    }
                 });
             }
         }
        // --- Clear Search ---
        function clearSearch() {
             const searchBox = document.getElementById("searchBox");
             const typeFilterSelect = document.getElementById("typeFilter");
             let changed = false;
             if(searchBox && searchBox.value !== "") { searchBox.value = ""; changed = true; }
             if(typeFilterSelect && typeFilterSelect.value !== "all") { typeFilterSelect.value = "all"; changed = true; }
             if (changed) {
                 renderMenu('id-tree');
             } else {
                  const menuElement = document.getElementById("menu");
                  if(menuElement) {
                       const infoMsgHtml = infoMessageDiv ? infoMessageDiv.outerHTML : '';
                       menuElement.innerHTML = infoMsgHtml;
                       if (Object.keys(rawData).length === 0) {
                             menuElement.style.display = 'none';
                             if(infoMessageDiv) infoMessageDiv.classList.add('d-none');
                             if(initialMessageDiv) initialMessageDiv.style.display = 'block';
                       } else {
                            renderMenu('id-tree');
                       }
                  }
             }
         }
        // MODIFICATION: Clear File Search
        function clearFileSearch() {
             const fileSearchBox = document.getElementById("fileSearchBox");
             let changed = false;
             if(fileSearchBox && fileSearchBox.value !== "") {
                  fileSearchBox.value = "";
                  changed = true;
             }
             if (changed) {
                  renderMenu('file-browser');
             } else {
                   renderMenu('file-browser');
             }
         }


        // --- IndexedDB Management ---
        function initDB() {
             return new Promise((resolve, reject) => {
                 if (db) { resolve(db); return; }
                 console.log(`Attempting to open IndexedDB ${DB_NAME} with version ${VERSION}`);
                 const request = indexedDB.open(DB_NAME, VERSION);
                 request.onerror = (event) => { console.error("IndexedDB Error:", event.target.error); reject(`L·ªói m·ªü IndexedDB: ${event.target.error?.message || event.target.error}`); };
                 request.onsuccess = (event) => { db = event.target.result; console.log(`IndexedDB ${DB_NAME} opened successfully (Version: ${db.version})`); db.onerror = (event) => { console.error(`Database error: ${event.target.error?.message || event.target.error}`); }; resolve(db); };
                 request.onupgradeneeded = (event) => {
                     console.log(`IndexedDB upgrade needed (Old Version: ${event.oldVersion}, New Version: ${event.newVersion})`);
                     db = event.target.result;
                     const transaction = event.target.transaction;

                     if (!db.objectStoreNames.contains(QUESTION_STORE_NAME)) {
                         db.createObjectStore(QUESTION_STORE_NAME, { keyPath: 'id' });
                         console.log(`Created object store: ${QUESTION_STORE_NAME}`);
                     }
                     if (!db.objectStoreNames.contains(METADATA_STORE_NAME)) {
                         db.createObjectStore(METADATA_STORE_NAME);
                         console.log(`Created object store: ${METADATA_STORE_NAME}`);
                     }
                     if (!db.objectStoreNames.contains(FILE_STORE_NAME)) {
                         db.createObjectStore(FILE_STORE_NAME, { keyPath: 'filePath' });
                         console.log(`Created object store: ${FILE_STORE_NAME}`);
                     }

                     if (event.oldVersion < 4) {
                         console.log("Applying structure for Version 4 (adding file store)");
                     }
                      if (event.oldVersion < 5) {
                         console.log(`Applying structure for Version 5 (new DB name, no structural changes needed in stores)`);
                      }

                 };
                 request.onblocked = () => { console.warn("IndexedDB open request blocked."); Swal.fire('L·ªói M·ªü Database', 'Trang kh√°c ƒëang s·ª≠ d·ª•ng database c≈©. Vui l√≤ng ƒë√≥ng c√°c tab kh√°c c·ªßa ·ª©ng d·ª•ng n√†y v√† th·ª≠ l·∫°i.', 'warning'); reject("IndexedDB blocked"); };
             });
         }

        // MODIFICATION: Load ALL question data from DB
        async function loadQuestionDataFromDB() { /* ... (no changes needed) ... */
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(QUESTION_STORE_NAME, 'readonly');
                const store = transaction.objectStore(QUESTION_STORE_NAME);
                const request = store.openCursor();
                const data = {};

                request.onerror = e => reject(`L·ªói ƒë·ªçc d·ªØ li·ªáu c√¢u h·ªèi t·ª´ DB: ${e.target.error?.message || e.target.error}`);
                request.onsuccess = e => {
                    const cursor = e.target.result;
                    if (cursor) {
                        const record = cursor.value;
                        if (record && record.id) {
                             data[record.id] = {
                                id: record.id,
                                desc: record.desc || 'N/A',
                                stats: classifyEx(record.exList || []),
                                sourceFiles: Array.isArray(record.sourceFiles) ? record.sourceFiles : [],
                                exList: Array.isArray(record.exList) ? record.exList : null
                            };
                        }
                        cursor.continue();
                    } else {
                        resolve(data);
                    }
                };
                transaction.onerror = (e) => reject(`L·ªói transaction khi ƒë·ªçc DB c√¢u h·ªèi: ${e.target.error?.message || e.target.error}`);
            });
        }

         // MODIFICATION: Load file data (path and name) from DB, applying exclusion filter
         async function loadFileDataFromDB() {
             if (!db) await initDB();
             return new Promise((resolve, reject) => {
                 const transaction = db.transaction(FILE_STORE_NAME, 'readonly');
                 const store = transaction.objectStore(FILE_STORE_NAME);
                 const request = store.openCursor();
                 const files = []; // [{ filePath, fileName }]

                 request.onerror = e => reject(`L·ªói ƒë·ªçc d·ªØ li·ªáu file t·ª´ DB: ${e.target.error?.message || e.target.error}`);
                 request.onsuccess = e => {
                     const cursor = e.target.result;
                     if (cursor) {
                         const record = cursor.value; // { filePath, content }
                         if (record && record.filePath) {
                             const pathParts = record.filePath.split('/');
                             const fileName = pathParts.pop() || record.filePath;
                             const fileNameLower = fileName.toLowerCase();
                             const isExcluded = EXCLUDED_FILE_PREFIXES.some(prefix => fileNameLower.startsWith(prefix));

                             if (!isExcluded) {
                                  files.push({ filePath: record.filePath, fileName: fileName });
                             }
                         }
                         cursor.continue();
                     } else {
                         resolve(files);
                     }
                 };
                 transaction.onerror = (e) => reject(`L·ªói transaction khi ƒë·ªçc DB file: ${e.target.error?.message || e.target.error}`);
             });
         }


        // Function to fetch full exList for a specific ID if needed
        async function fetchExListIfNeeded(id) { /* ... (no changes needed) ... */
            if (!id || !rawData[id] || rawData[id].exList !== null) {
                return rawData[id]?.exList;
            }
            console.log(`Lazy loading exList for ID: ${id}`);
            showLoading(true, `ƒêang t·∫£i n·ªôi dung cho ID: ${id}...`);
            try {
                if (!db) await initDB();
                const transaction = db.transaction(QUESTION_STORE_NAME, 'readonly');
                const store = transaction.objectStore(QUESTION_STORE_NAME);
                const request = store.get(id);

                return new Promise((resolve, reject) => {
                    request.onerror = e => { console.error(`Error fetching exList for ${id}:`, e.target.error); reject(e.target.error); };
                    request.onsuccess = e => {
                        const record = e.target.result;
                        if (record && rawData[id]) {
                            rawData[id].exList = Array.isArray(record.exList) ? record.exList : [];
                            resolve(rawData[id].exList);
                        } else {
                            console.warn(`Record for ID ${id} not found in DB during fetch or rawData entry missing.`);
                             if(rawData[id]) rawData[id].exList = [];
                            resolve([]);
                        }
                    };
                });
            } catch (error) {
                console.error(`Error initiating fetchExList for ${id}:`, error);
                if(rawData[id]) rawData[id].exList = [];
                return [];
            } finally {
                 showLoading(false);
            }
        }

        // Function to add/update question data to DB
        async function addOrUpdateDataInDB(newDataBatch) { /* ... (no changes needed) ... */
             if (!db) await initDB();
             const newIds = Object.keys(newDataBatch);
             if (newIds.length === 0) return { success: 0, errors: 0, skipped: 0 };
             console.log(`Attempting to add/update ${newIds.length} question IDs in IndexedDB.`);

             const transaction = db.transaction([QUESTION_STORE_NAME, METADATA_STORE_NAME], 'readwrite');
             const questionStore = transaction.objectStore(QUESTION_STORE_NAME);
             const metaStore = transaction.objectStore(METADATA_STORE_NAME);

             let successCount = 0, errorCount = 0, skippedCount = 0;
             const existingRecordsMap = new Map();

             try {
                 const getPromises = newIds.map(id => {
                     return new Promise((resolve, reject) => {
                         const request = questionStore.get(id);
                         request.onsuccess = (event) => resolve({ id: id, value: event.target.result });
                         request.onerror = (event) => reject({ id: id, error: event.target.error });
                     });
                 });
                 const getResults = await Promise.allSettled(getPromises);
                 getResults.forEach(result => {
                     if (result.status === 'fulfilled' && result.value && result.value.value !== undefined) {
                         existingRecordsMap.set(result.value.id, result.value.value);
                     } else if (result.status === 'rejected') {
                         console.error(`Error fetching existing record for ID ${result.reason?.id}:`, result.reason?.error);
                     }
                 });
             } catch (setupError) {
                 console.error("Error setting up fetch for existing question records batch:", setupError);
             }

             const putPromises = newIds.map(id => {
                  return (async () => {
                       try {
                           const existingRecord = existingRecordsMap.get(id);
                           const newData = newDataBatch[id];

                           let recordToPut;
                           let isUpdateNeeded = false;

                           if (existingRecord) {
                               const existingExList = Array.isArray(existingRecord.exList) ? existingRecord.exList : [];
                               const newExList = Array.isArray(newData.exList) ? newData.exList : [];
                               const existingExSet = new Set(existingExList);
                               const uniqueNewBlocks = newExList.filter(block => !existingExSet.has(block));

                               const existingSourceFiles = new Set(Array.isArray(existingRecord.sourceFiles) ? existingRecord.sourceFiles : []);
                               const newSourceFiles = Array.isArray(newData.sourceFiles) ? newData.sourceFiles : [];
                               newSourceFiles.forEach(filePath => existingSourceFiles.add(filePath));
                               const finalSourceFiles = Array.from(existingSourceFiles).sort();

                               let finalDesc = existingRecord.desc;
                               const predefinedDesc = getPredefinedDescById(id);
                               if (predefinedDesc && predefinedDesc !== finalDesc) { finalDesc = predefinedDesc; isUpdateNeeded = true; }
                               else if ((!finalDesc || finalDesc === 'N/A' || finalDesc.trim() === '') && (newData.desc && newData.desc.trim() !== '') && !predefinedDesc) {
                                   finalDesc = newData.desc.trim();
                                   isUpdateNeeded = true;
                               } else if (newData.desc && newData.desc.trim() !== '' && newData.desc.trim() !== finalDesc && !predefinedDesc) {
                                   finalDesc = newData.desc.trim();
                                    isUpdateNeeded = true;
                               }


                               const sourceFilesChanged = JSON.stringify(finalSourceFiles) !== JSON.stringify(Array.isArray(existingRecord.sourceFiles) ? existingRecord.sourceFiles.sort() : []);

                               if (uniqueNewBlocks.length > 0 || isUpdateNeeded || sourceFilesChanged) {
                                   const combinedExList = [...existingExList, ...uniqueNewBlocks];
                                   recordToPut = {
                                       id: id,
                                       desc: finalDesc,
                                       exList: combinedExList,
                                       sourceFiles: finalSourceFiles,
                                       stats: classifyEx(combinedExList)
                                   };
                                   isUpdateNeeded = true;
                               } else {
                                   skippedCount++;
                                   return;
                               }
                           } else {
                               const newExList = Array.isArray(newData.exList) ? newData.exList : [];
                               if (newExList.length === 0) {
                                   console.warn(`Skipping put for new ID ${id}: No blocks found.`);
                                   skippedCount++;
                                   return;
                               }
                               const predefinedDesc = getPredefinedDescById(id);
                               const newSourceFiles = Array.isArray(newData.sourceFiles) ? newData.sourceFiles.sort() : [];
                               recordToPut = {
                                   id: id,
                                   desc: predefinedDesc || ((newData.desc && newData.desc.trim() !== '') ? newData.desc.trim() : 'N/A'),
                                   exList: newExList,
                                   sourceFiles: newSourceFiles,
                                   stats: classifyEx(newExList)
                               };
                               isUpdateNeeded = true;
                           }

                           if (isUpdateNeeded) {
                               await new Promise((resolve, reject) => {
                                   const putRequest = questionStore.put(recordToPut);
                                   putRequest.onsuccess = resolve;
                                   putRequest.onerror = (e) => { console.error(`Put failed for ID ${id}: ${e.target.error?.message}`); reject(new Error(`Put failed for ID ${id}`)); };
                               });
                               successCount++;
                           }
                       } catch (error) {
                           console.error(`Error processing question ID ${id} for saving:`, error);
                           errorCount++;
                       }
                  })();
             });

             await Promise.allSettled(putPromises);

             try { await new Promise((res, rej) => { const r = metaStore.put(Date.now(), 'lastUpdate'); r.onsuccess=res; r.onerror=rej; }); }
             catch(metaError){ console.error("Failed timestamp update:", metaError); }

             return new Promise((resolve, reject) => {
                  transaction.oncomplete = () => { console.log(`DB Question Add/Update Tx Complete. Success: ${successCount}, Errors: ${errorCount}, Skipped: ${skippedCount}`); resolve({ success: successCount, errors: errorCount, skipped: skippedCount }); };
                  transaction.onerror = (event) => { console.error("DB Question Add/Update Tx Error:", event.target.error); reject(new Error(`L·ªói transaction khi l∆∞u DB c√¢u h·ªèi: ${event.target.error?.message || event.target.error}`)); };
             });
         }


        // Function to add/update file content in the FILE_STORE_NAME
        async function addFilesToDB(filesData) {
            if (!db) await initDB();
            if (!Array.isArray(filesData) || filesData.length === 0) {
                console.log("No file data provided to addFilesToDB.");
                return { success: 0, errors: 0 };
            }
            console.log(`Attempting to add/update ${filesData.length} files in IndexedDB.`);

            const transaction = db.transaction(FILE_STORE_NAME, 'readwrite');
            const fileStore = transaction.objectStore(FILE_STORE_NAME);
            let successCount = 0, errorCount = 0;

            const putPromises = filesData.map(fileInfo => {
                return new Promise((resolve, reject) => {
                    if (!fileInfo || !fileInfo.filePath || typeof fileInfo.content !== 'string') {
                        console.warn("Skipping invalid file data:", fileInfo);
                        reject(new Error("Invalid file data format"));
                        return;
                    }
                    const request = fileStore.put({ filePath: fileInfo.filePath, content: fileInfo.content });
                    request.onsuccess = () => resolve();
                    request.onerror = (e) => { console.error(`Error putting file ${fileInfo.filePath}:`, e.target.error); reject(e.target.error); };
                });
            });

            const results = await Promise.allSettled(putPromises);

            results.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    successCount++;
                } else {
                    errorCount++;
                    console.error(`Failed to save file data for path "${filesData[index]?.filePath}":`, result.reason);
                }
            });

            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => {
                    console.log(`DB File Add/Update Tx Complete. Success: ${successCount}, Errors: ${errorCount}`);
                    fileContentCache.clear();
                    resolve({ success: successCount, errors: errorCount });
                };
                transaction.onerror = (event) => {
                    console.error("DB File Add/Update Tx Error:", event.target.error);
                    reject(new Error(`L·ªói transaction khi l∆∞u DB file: ${event.target.error?.message || event.target.error}`));
                };
            });
        }

         // Function to get file content from DB (used for modal)
         async function getFileContentFromDB(filePath) { /* ... (no changes needed) ... */
             if (fileContentCache.has(filePath)) { return fileContentCache.get(filePath); }
             if (!db) await initDB();
             return new Promise((resolve, reject) => {
                 const transaction = db.transaction(FILE_STORE_NAME, 'readonly');
                 const store = transaction.objectStore(FILE_STORE_NAME);
                 const request = store.get(filePath);
                 request.onerror = e => { console.error(`Error fetching file ${filePath}:`, e.target.error); reject(`L·ªói ƒë·ªçc file t·ª´ DB: ${e.target.error?.message || e.target.error}`); };
                 request.onsuccess = e => {
                     const record = e.target.result;
                     if (record && typeof record.content === 'string') { fileContentCache.set(filePath, record.content); resolve(record.content); }
                     else { console.warn(`File content not found or invalid for path: ${filePath}`); resolve(null); }
                 };
                 transaction.onerror = (e) => reject(`L·ªói transaction khi ƒë·ªçc DB file: ${e.target.error?.message || e.target.error}`);
             });
         }


        // --- Local File Handling ---
        // Processes files for both questions and file content storage
        async function handleFolderSelection(event) {
            const files = event.target.files; if (!files || files.length === 0) { return; }
            const fileArray = Array.from(files); const texFiles = fileArray.filter(file => file.name.toLowerCase().endsWith('.tex'));
            if (texFiles.length === 0) { Swal.fire('Kh√¥ng c√≥ file .tex', 'Kh√¥ng t√¨m th·∫•y file .tex n√†o trong th∆∞ m·ª•c ƒë√£ ch·ªçn.', 'info'); event.target.value = null; return; }

            const filteredTexFiles = texFiles.filter(file => {
                const fileNameLower = file.name.toLowerCase();
                return !EXCLUDED_FILE_PREFIXES.some(prefix => fileNameLower.startsWith(prefix));
            });

            const excludedCount = texFiles.length - filteredTexFiles.length;
            if (excludedCount > 0) {
                 console.log(`Excluded ${excludedCount} files based on prefixes: ${EXCLUDED_FILE_PREFIXES.join(', ')}`);
                 if (filteredTexFiles.length === 0) {
                     Swal.fire('Kh√¥ng c√≥ file h·ª£p l·ªá', `T·∫•t c·∫£ ${texFiles.length} file .tex ƒë·ªÅu b·∫Øt ƒë·∫ßu b·∫±ng c√°c ti·ªÅn t·ªë b·ªã b·ªè qua (${EXCLUDED_FILE_PREFIXES.join(', ')}).`, 'info');
                     event.target.value = null;
                     return;
                 }
            }

             showLoading(true, `ƒêang x·ª≠ l√Ω ${filteredTexFiles.length} file .tex...`);
            const startTime = Date.now();
            const allParsedQuestionData = {};
            const allFileData = [];
            let totalBlocksFound = 0;

             const processingPromises = filteredTexFiles.map(async (file) => {
                 try {
                    const result = await readFileContent(file);
                    return result;
                 } catch (fileError) {
                      console.error(`L·ªói x·ª≠ l√Ω file "${file.name}":`, fileError);
                      return null;
                 }
             });

            const results = await Promise.all(processingPromises);

            results.forEach(result => {
                 if (!result) return;

                 if (result.relativePath && typeof result.fullContent === 'string') {
                     allFileData.push({ filePath: result.relativePath, content: result.fullContent });
                 }

                 if (result.blocks && result.relativePath) {
                      const pathParts = result.relativePath.split('/');
                      pathParts.pop();
                      const pathDesc = pathParts.map(p => p.trim()).filter(Boolean).join(' | ') || 'Th∆∞ m·ª•c g·ªëc';

                      result.blocks.forEach(({ internalId, blockContent }) => {
                           totalBlocksFound++;
                           const trimmedId = internalId.trim();
                           if (!allParsedQuestionData[trimmedId]) {
                               const defaultDesc = pathDesc;
                               allParsedQuestionData[trimmedId] = {
                                   id: trimmedId,
                                   desc: defaultDesc,
                                   exList: [],
                                   sourceFiles: []
                               };
                           } else if ((!allParsedQuestionData[trimmedId].desc || allParsedQuestionData[trimmedId].desc === 'N/A') && pathDesc !== 'Th∆∞ m·ª•c g·ªëc') {
                                allParsedQuestionData[trimmedId].desc = pathDesc;
                           }
                           allParsedQuestionData[trimmedId].exList.push(blockContent);
                           if (!allParsedQuestionData[trimmedId].sourceFiles.includes(result.relativePath)) {
                               allParsedQuestionData[trimmedId].sourceFiles.push(result.relativePath);
                           }
                      });
                 }
            });

            const processingTime = Date.now() - startTime;
            const uniqueIDs = Object.keys(allParsedQuestionData).length;
            console.log(`ƒê√£ x·ª≠ l√Ω ${filteredTexFiles.length} file trong ${processingTime} ms. T√¨m th·∫•y ${totalBlocksFound} block thu·ªôc ${uniqueIDs} ID. Chu·∫©n b·ªã l∆∞u ${allFileData.length} file v√†o DB.`);

            if (uniqueIDs > 0 || allFileData.length > 0) {
                let dbQuestionResult = { success: 0, errors: 0, skipped: 0 };
                let dbFileResult = { success: 0, errors: 0 };

                try {
                    if (uniqueIDs > 0) {
                         showLoading(true, `ƒêang l∆∞u ${uniqueIDs} ID c√¢u h·ªèi v√†o cache...`);
                         dbQuestionResult = await addOrUpdateDataInDB(allParsedQuestionData);
                         console.log("K·∫øt qu·∫£ l∆∞u DB c√¢u h·ªèi:", dbQuestionResult);
                    }
                    if (allFileData.length > 0) {
                         showLoading(true, `ƒêang l∆∞u n·ªôi dung ${allFileData.length} file v√†o cache...`);
                         dbFileResult = await addFilesToDB(allFileData);
                         console.log("K·∫øt qu·∫£ l∆∞u DB file:", dbFileResult);
                    }

                    await loadAllDataAndRenderUI();

                    let summaryMsg = `ƒê√£ x·ª≠ l√Ω ${filteredTexFiles.length} file.${excludedCount > 0 ? ` (ƒê√£ b·ªè qua ${excludedCount} file)` : ''}<br>`;
                    summaryMsg += `C√¢u h·ªèi - Th√™m/C·∫≠p nh·∫≠t v√†o cache c·ª•c b·ªô: ${dbQuestionResult.success}, L·ªói: ${dbQuestionResult.errors}, B·ªè qua (ƒë√£ c√≥): ${dbQuestionResult.skipped}<br>`;
                    summaryMsg += `File - L∆∞u n·ªôi dung v√†o cache c·ª•c b·ªô: ${dbFileResult.success}, L·ªói: ${dbFileResult.errors}<br>`;
                    summaryMsg += `<small class="text-muted">T·ªïng ID c√¢u h·ªèi trong cache: ${totalDbQuestionCount}, T·ªïng File trong cache: ${totalDbFileCount}</small>`;
                    Swal.fire('Ho√†n th√†nh', summaryMsg, 'success');

                } catch(dbError) {
                    console.error("Error saving data after folder selection:", dbError);
                    Swal.fire('L·ªói L∆∞u DB', `L·ªói khi l∆∞u d·ªØ li·ªáu t·ª´ th∆∞ m·ª•c: ${dbError.message || dbError}`, 'error');
                    await loadAllDataAndRenderUI();
                } finally {
                     showLoading(false);
                }
            } else {
                Swal.fire('Kh√¥ng c√≥ d·ªØ li·ªáu', `Kh√¥ng t√¨m th·∫•y block ID h·ª£p l·ªá (%[...] ) ho·∫∑c n·ªôi dung file trong c√°c file .tex ƒë√£ ch·ªçn (${filteredTexFiles.length} file sau l·ªçc).`, 'info');
                showLoading(false);
            }
            event.target.value = null;
        }

        // Reads full content and extracts blocks (Corrected Regex)
        function readFileContent(file) {
             return new Promise((resolve, reject) => {
                 const reader = new FileReader();
                 reader.onload = (e) => {
                     try {
                         const fullContent = e.target.result;
                         if (typeof fullContent !== 'string') {
                             throw new Error("File content is not a string.");
                         }
                         const blocks = extractBlocksAndInternalId_Client(fullContent);

                         const relativePath = file.webkitRelativePath || file.name;
                         const pathParts = relativePath.split('/');
                         const fileName = pathParts.pop() || file.name;
                         const folderPath = pathParts.join('/');

                         resolve({
                             fileName: fileName,
                             relativePath: relativePath,
                             folderPath: folderPath,
                             fullContent: fullContent,
                             blocks: blocks
                         });
                     } catch (processingError) {
                         console.error(`L·ªói x·ª≠ l√Ω n·ªôi dung file "${file.name}":`, processingError);
                         resolve(null);
                     }
                 };
                 reader.onerror = (e) => {
                     console.error(`L·ªói ƒë·ªçc file "${file.name}":`, e.target.error);
                     reject(e.target.error);
                 };
                 reader.readAsText(file, 'UTF-8');
             });
        }

        // MODIFICATION: Corrected regex for %[ID] format
       // MODIFICATION: H√†m ƒë∆∞·ª£c s·ª≠a ƒë·ªÉ ch·ªâ t√¨m ki·∫øm ID c√≥ ƒë·ªãnh d·∫°ng c·ª• th·ªÉ "%[s·ªë ch·ªØ s·ªë ch·ªØ s·ªë - s·ªë]", b·ªè qua \%[...]
function extractBlocksAndInternalId_Client(content) {
    if (typeof content !== 'string') {
        console.warn("extractBlocksAndInternalId_Client received non-string content.");
        return [];
    }
    const blocks = [];
    // Regex ƒë·ªÉ t√¨m c√°c block \begin{ex|vd|bt}...\end{ex|vd|bt}
    // c·ªù 'g' ƒë·ªÉ t√¨m t·∫•t c·∫£, 's' ƒë·ªÉ d·∫•u '.' kh·ªõp c·∫£ newline
    const blockRegex = /\\begin\{\s*(ex|vd|bt)\s*\}(.*?)\\end\{\s*\1\s*\}/gs;
    const matches = [...content.matchAll(blockRegex)]; // T√¨m t·∫•t c·∫£ c√°c block

    console.log(`[extractBlocks] Found ${matches.length} potential blocks using regex: ${blockRegex}`);

    // Regex ƒë·ªÉ t√¨m T·∫§T C·∫¢ c√°c tag pattern '%[' theo sau l√† n·ªôi dung b·∫•t k·ª≥ v√† k·∫øt th√∫c b·∫±ng ']'.
    // CH·ªà kh·ªõp v·ªõi '%[', KH√îNG kh·ªõp v·ªõi '\%['
    // C·ªù 'g' ƒë·ªÉ t√¨m t·∫•t c·∫£ c√°c l·∫ßn xu·∫•t hi·ªán trong innerContent.
    // match[1] s·∫Ω b·∫Øt gi·ªØ n·ªôi dung b√™n trong [].
    const allTagsRegex = /%\[(.*?)\]/g; // MODIFIED regex to ONLY handle %[

    // Regex ƒë·ªÉ ki·ªÉm tra xem n·ªôi dung B√äN TRONG tag [%] c√≥ kh·ªõp v·ªõi ƒë·ªãnh d·∫°ng ID mong mu·ªën kh√¥ng.
    // ƒê·ªãnh d·∫°ng ID: m·ªôt ch·ªØ s·ªë, m·ªôt ch·ªØ c√°i in hoa, m·ªôt ch·ªØ s·ªë, (ch·ªØ c√°i in hoa HO·∫∂C ch·ªØ s·ªë), m·ªôt ch·ªØ s·ªë, d·∫•u g·∫°ch ngang, m·ªôt ho·∫∑c nhi·ªÅu ch·ªØ s·ªë.
    // ^\s* v√† \s*$ ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng c√≥ k√Ω t·ª± th·ª´a (ngo√†i kho·∫£ng tr·∫Øng) ·ªü ƒë·∫ßu ho·∫∑c cu·ªëi n·ªôi dung tag.
    const specificIdContentRegex = /^\s*(\d[A-Z]\d[A-Z0-9]\d-\d+)\s*$/; // B·∫Øt gi·ªØ ph·∫ßn ID c·ª• th·ªÉ (\d[A-Z]\d[A-Z0-9]\d-\d+)


    matches.forEach((match, matchIndex) => {
         const fullBlock = match[0];
         const innerContent = match[2]; // N·ªôi dung *b√™n trong* block

         let blockInternalId = null; // Kh·ªüi t·∫°o ID l√† null cho block n√†y
         let firstMatchingTagContent = null; // L∆∞u n·ªôi dung tag ƒë·∫ßu ti√™n kh·ªõp ƒë·ªãnh d·∫°ng (ƒë·ªÉ log)
         let firstMatchingTagFull = null; // L∆∞u to√†n b·ªô tag ƒë·∫ßu ti√™n kh·ªõp ƒë·ªãnh d·∫°ng (ƒë·ªÉ log)

         console.group(`[extractBlocks] Processing block ${matchIndex + 1} (start at char ${match.index}):`);
         console.log(`  Inner Content (first 150 chars, newlines escaped): "${innerContent.substring(0, 150).replace(/\n/g, '\\n')}..."`);
         console.log(`  Searching for tags using regex: ${allTagsRegex}`);

         // T√¨m T·∫§T C·∫¢ c√°c tag %[...] trong innerContent
         const allTagMatches = [...innerContent.matchAll(allTagsRegex)];
         console.log(`  Found ${allTagMatches.length} potential "%[...]" tags within this block.`);
         console.log(`  Specific ID content pattern to match: ${specificIdContentRegex}`);


         // Duy·ªát qua T·∫§T C·∫¢ c√°c tag t√¨m th·∫•y ƒë·ªÉ t√¨m tag ƒë·∫ßu ti√™n kh·ªõp v·ªõi ƒë·ªãnh d·∫°ng ID c·ª• th·ªÉ
         for (const tagMatch of allTagMatches) {
             const tagContent = tagMatch[1]; // N·ªôi dung b√™n trong tag [%]
             const fullTag = tagMatch[0]; // To√†n b·ªô tag (v√≠ d·ª•: "%[0D3N1-1]")

             console.log(`    Checking tag: "${fullTag}" (content: "${tagContent.replace(/\n/g, '\\n')}")`);

             // Ki·ªÉm tra n·ªôi dung tag v·ªõi regex ƒë·ªãnh d·∫°ng ID c·ª• th·ªÉ
             const specificIdMatch = tagContent.match(specificIdContentRegex);

             if (specificIdMatch) {
                 // N·∫øu kh·ªõp, ƒë√¢y l√† ID ch√∫ng ta mu·ªën. L·∫•y ph·∫ßn b·∫Øt gi·ªØ (capture group 1) l√† ID ƒë√£ ƒë∆∞·ª£c trim nh·ªù specificIdContentRegex.
                 blockInternalId = specificIdMatch[1];
                 firstMatchingTagContent = tagContent; // L∆∞u l·∫°i ƒë·ªÉ log
                 firstMatchingTagFull = fullTag; // L∆∞u l·∫°i ƒë·ªÉ log

                 console.log(`    ==BINGO!> Found FIRST tag matching specific ID format. ID: "${blockInternalId}" from tag "${firstMatchingTagFull}".`);
                 break; // D·ª´ng ngay sau khi t√¨m th·∫•y tag ƒë·∫ßu ti√™n kh·ªõp ƒë·ªãnh d·∫°ng
             } else {
                 console.log(`    Tag "${fullTag}" does NOT match specific ID format.`);
             }
         }

         console.log(`  Final extracted ID for block ${matchIndex + 1}: "${blockInternalId}"`);


         // N·∫øu t√¨m th·∫•y ID h·ª£p l·ªá (kh√¥ng null), th√™m block v√†o danh s√°ch
         // specificIdContentRegex ƒë·∫£m b·∫£o n√≥ kh√¥ng r·ªóng n·∫øu kh·ªõp
         if (blockInternalId !== null) {
             blocks.push({ internalId: blockInternalId, blockContent: fullBlock });
             console.log(`  Block ${matchIndex + 1} ADDED with ID "${blockInternalId}". Total added: ${blocks.length}.`);
         } else {
             // N·∫øu kh√¥ng t√¨m th·∫•y tag n√†o kh·ªõp ƒë·ªãnh d·∫°ng ID c·ª• th·ªÉ sau khi duy·ªát t·∫•t c·∫£
             console.warn(`[extractBlocks] Block ${matchIndex + 1} SKIPPED: No "%[...]" tag found matching specific ID format (${specificIdContentRegex}).`);
             // Log v√†i k√Ω t·ª± ƒë·∫ßu c·ªßa block ƒë·∫ßy ƒë·ªß ƒë·ªÉ gi√∫p x√°c ƒë·ªãnh trong file ngu·ªìn
             console.warn(`  Skipped Block content (first 150 chars, newlines escaped): "${fullBlock.substring(0, 150).replace(/\n/g, '\\n')}..."`);
         }
         console.groupEnd(); // K·∫øt th√∫c group log
    });

    console.log(`[extractBlocks] Final count of blocks successfully added with specific format IDs: ${blocks.length}`);

    return blocks;
}

        // MODIFICATION: Clear both question and file stores
        async function clearLocalCache() { /* ... (no changes needed) ... */
             Swal.fire({ title: 'B·∫°n c√≥ ch·∫Øc ch·∫Øn?', text: "X√≥a to√†n b·ªô cache c√¢u h·ªèi V√Ä cache file ƒë√£ l∆∞u?", icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', confirmButtonText: 'V√¢ng, x√≥a h·∫øt!' })
             .then(async (result) => {
                 if (result.isConfirmed) {
                     showLoading(true, 'ƒêang x√≥a cache...');
                     try {
                         if (!db) await initDB();
                         const storeNames = db.objectStoreNames;
                         const storesToClear = [];
                         if(storeNames.contains(QUESTION_STORE_NAME)) storesToClear.push(QUESTION_STORE_NAME);
                         if(storeNames.contains(FILE_STORE_NAME)) storesToClear.push(FILE_STORE_NAME);
                         if(storeNames.contains(METADATA_STORE_NAME)) storesToClear.push(METADATA_STORE_NAME);

                         if (storesToClear.length > 0) {
                             const tx = db.transaction(storesToClear, 'readwrite');
                             const clearPromises = storesToClear.map(name => new Promise((res, rej) => {
                                 const request = tx.objectStore(name).clear();
                                 request.onsuccess = res;
                                 request.onerror = (e) => rej(e.target.error);
                             }));
                             await Promise.all(clearPromises);
                             await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = (e) => rej(e.target.error); });
                             console.log(`Cleared stores: ${storesToClear.join(', ')}`);
                         } else {
                             console.log("No stores found to clear.");
                         }

                         rawData = {};
                         loadedFiles = [];
                         selectedIDs.clear();
                         fileContentCache.clear();
                         totalDbQuestionCount = 0;
                         totalDbFileCount = 0;

                         const menuElement = document.getElementById("menu");
                         if(menuElement) { menuElement.innerHTML = ""; menuElement.style.display = 'none'; }
                         if(initialMessageDiv) initialMessageDiv.style.display = 'block';
                         if(infoMessageDiv) infoMessageDiv.classList.add('d-none');
                         updateSelectedIDsTable();
                         document.getElementById('mockResult').innerHTML = '';
                          // MODIFICATION: Hide duplicate results area
                          if(duplicateResultsArea) duplicateResultsArea.classList.add('d-none');

                         if (typeof clearGrabbedContent === 'function') clearGrabbedContent();

                         Swal.fire('ƒê√£ x√≥a!', 'To√†n b·ªô cache c·ª•c b·ªô ƒë√£ ƒë∆∞·ª£c x√≥a.', 'success');

                     } catch (error) {
                         console.error("L·ªói x√≥a cache:", error);
                         Swal.fire('L·ªói', `Kh√¥ng th·ªÉ x√≥a cache: ${error?.message || error}`, 'error');
                         loadAllDataAndRenderUI();
                     } finally {
                         showLoading(false);
                     }
                 }
             });
        }

        // Download exports ALL question data from DB
        async function downloadData() { /* ... (no changes needed) ... */
             showLoading(true, "ƒêang chu·∫©n b·ªã d·ªØ li·ªáu c√¢u h·ªèi t·∫£i v·ªÅ...");
             try {
                 if (!db) await initDB();
                 const transaction = db.transaction(QUESTION_STORE_NAME, 'readonly');
                 const store = transaction.objectStore(QUESTION_STORE_NAME);
                 const getAllRequest = store.getAll();

                 const dataToSaveArray = await new Promise((resolve, reject) => {
                     getAllRequest.onsuccess = (event) => resolve(event.target.result || []);
                     getAllRequest.onerror = (event) => reject(event.target.error);
                     transaction.onerror = (event) => reject(event.target.error);
                 });

                 const dataCount = dataToSaveArray.length;
                 if (dataCount === 0) { Swal.fire('Kh√¥ng c√≥ d·ªØ li·ªáu', 'Cache c√¢u h·ªèi tr·ªëng.', 'info'); showLoading(false); return; }

                 const cleanedData = {};
                 dataToSaveArray.forEach(record => {
                      if (record && record.id) {
                           cleanedData[record.id] = {
                                id: record.id,
                                desc: record.desc || 'N/A',
                                exList: Array.isArray(record.exList) ? record.exList : []
                           };
                      }
                 });

                 const jsonString = JSON.stringify(cleanedData, null, 2);
                 const blob = new Blob([jsonString], { type: 'application/json' });
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url;
                 const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                 a.download = `latex_bank_questions_backup_${dateStr}.json`;
                 document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                 showLoading(false);
                 Swal.fire('ƒê√£ t·∫£i v·ªÅ!', `ƒê√£ xu·∫•t ${dataCount} ID c√¢u h·ªèi (t·∫•t c·∫£ ID trong cache c·ª•c b·ªô) v√†o file JSON.`, 'success');
             } catch (error) {
                 console.error("L·ªói khi t·∫£i v·ªÅ d·ªØ li·ªáu c√¢u h·ªèi:", error);
                 showLoading(false);
                 Swal.fire('L·ªói T·∫£i V·ªÅ', `Kh√¥ng th·ªÉ t·∫£i v·ªÅ d·ªØ li·ªáu c√¢u h·ªèi: ${error?.message || error}`, 'error');
             }
        }

        // Upload handles JSON containing { id: { id, desc, exList } }
        function handleUploadSelection(event) { /* ... (no changes needed) ... */
             const file = event.target.files[0]; if (!file) { event.target.value = null; return; } if (!file.name.toLowerCase().endsWith('.json')) { Swal.fire('Sai ƒë·ªãnh d·∫°ng', 'Vui l√≤ng ch·ªçn file .json ch·ª©a cache c√¢u h·ªèi', 'warning'); event.target.value = null; return; } Swal.fire({ title: 'N·∫°p Cache C√¢u H·ªèi?', html: `N·∫°p d·ªØ li·ªáu c√¢u h·ªèi t·ª´ file <b>${escapeHtml(file.name)}</b>?<br>D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c **g·ªôp** v√†o cache c√¢u h·ªèi hi·ªán c√≥. Cache file s·∫Ω kh√¥ng b·ªã ·∫£nh h∆∞·ªüng.`, icon: 'question', showCancelButton: true, confirmButtonText: 'V√¢ng, n·∫°p d·ªØ li·ªáu!' }).then(async (result) => { if (result.isConfirmed) { await processUploadFile(file); } event.target.value = null; });
        }
        async function processUploadFile(file) { /* ... (no changes needed) ... */
            showLoading(true, `ƒêang ƒë·ªçc file cache c√¢u h·ªèi "${file.name}"...`);
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    showLoading(true, "ƒêang ph√¢n t√≠ch d·ªØ li·ªáu c√¢u h·ªèi...");
                    const uploadedData = JSON.parse(e.target.result);
                    if (typeof uploadedData !== 'object' || uploadedData === null) throw new Error("File JSON kh√¥ng ch·ª©a object.");

                    const dataToProcess = {}; let validIdCount = 0;
                    for (const id in uploadedData) {
                         if (Object.prototype.hasOwnProperty.call(uploadedData, id)) {
                              const item = uploadedData[id];
                              if (typeof item === 'object' && item !== null && item.id === id) {
                                   const exList = Array.isArray(item.exList) ? item.exList : [];
                                   const defaultDesc = ((item.desc && item.desc.trim() !== '') ? item.desc.trim() : 'N/A');
                                   dataToProcess[id] = {
                                       id: id,
                                       desc: defaultDesc,
                                       exList: exList
                                   };
                                   validIdCount++;
                              } else { console.warn(`Skipping invalid question record in JSON for key "${id}":`, item); }
                         }
                    }
                    if (validIdCount === 0) throw new Error("Kh√¥ng t√¨m th·∫•y ID c√¢u h·ªèi h·ª£p l·ªá trong file JSON.");
                    console.log(`T√¨m th·∫•y ${validIdCount} ID c√¢u h·ªèi h·ª£p l·ªá trong file t·∫£i l√™n. Chu·∫©n b·ªã g·ªôp v√†o DB.`);
                    showLoading(true, `ƒêang g·ªôp ${validIdCount} ID c√¢u h·ªèi v√†o cache c·ª•c b·ªô...`);

                    const dbResult = await addOrUpdateDataInDB(dataToProcess);
                    console.log("K·∫øt qu·∫£ g·ªôp c√¢u h·ªèi t·ª´ file t·∫£i l√™n:", dbResult);
                    await loadAllDataAndRenderUI();

                    let summaryMsg = `ƒê√£ g·ªôp d·ªØ li·ªáu c√¢u h·ªèi t·ª´ file "${escapeHtml(file.name)}".`;
                    if (dbResult.success > 0) summaryMsg += `<br>Th√†nh c√¥ng: ${dbResult.success} ID.`;
                    if (dbResult.errors > 0) summaryMsg += `<br>L·ªói: ${dbResult.errors} ID.`;
                    if (dbResult.skipped > 0) summaryMsg += `<br>B·ªè qua: ${dbResult.skipped} ID.`;
                    summaryMsg += `<br><small class="text-muted">T·ªïng ID c√¢u h·ªèi trong cache: ${totalDbQuestionCount}, T·ªïng File trong cache: ${totalDbFileCount}</small>`;
                    Swal.fire('Ho√†n th√†nh', summaryMsg, 'success');
                } catch (error) {
                    console.error("L·ªói x·ª≠ l√Ω file JSON c√¢u l√™n:", error);
                    Swal.fire('L·ªói N·∫°p D·ªØ Li·ªáu', `Kh√¥ng th·ªÉ n·∫°p t·ª´ "${escapeHtml(file.name)}": ${error?.message || error}`, 'error');
                    loadAllDataAndRenderUI();
                } finally { showLoading(false); }
            };
            reader.onerror = (e) => { console.error(`L·ªói ƒë·ªçc file "${file.name}":`, e.target.error); showLoading(false); Swal.fire('L·ªói ƒê·ªçc File', `Kh√¥ng th·ªÉ ƒë·ªçc file "${escapeHtml(file.name)}".`, 'error'); };
            reader.readAsText(file, 'UTF-8');
        }

        // Consolidated DB Error Handling
        function handleDBError(error) { /* ... (no changes needed) ... */
             console.error("L·ªói IndexedDB:", error);
             Swal.fire('L·ªói Database', `L·ªói database c·ª•c b·ªô: ${error?.message || error}. Th·ª≠ l·∫°i ho·∫∑c x√≥a cache.`, 'error');
             const menuElement = document.getElementById("menu");
             if(menuElement) {
                  const infoMsgHtml = infoMessageDiv ? infoMessageDiv.outerHTML : '';
                  menuElement.innerHTML = infoMsgHtml + `<p class="text-danger mt-3">L·ªói truy c·∫≠p database: ${escapeHtml(error?.message || error)}</p>`;
                  menuElement.style.display = 'block';
             }
             if(initialMessageDiv) { initialMessageDiv.style.display = 'none'; }
             if(infoMessageDiv) { infoMessageDiv.classList.add('d-none'); }

             rawData = {};
             loadedFiles = [];
             selectedIDs.clear();
             fileContentCache.clear();
             totalDbQuestionCount = 0;
             totalDbFileCount = 0;

             updateSelectedIDsTable();
             document.getElementById('mockResult').innerHTML = '';
              if(duplicateResultsArea) duplicateResultsArea.classList.add('d-none');

             if (typeof clearGrabbedContent === 'function') clearGrabbedContent();
             else { const ga=document.getElementById('grabbedContentArea'); if(ga) ga.classList.add('d-none'); const gc=document.getElementById('grabbedContentBlocks'); if(gc) gc.innerHTML=''; }
        }

        // --- UI Rendering & Interaction ---

        // MODIFICATION: Main rendering function based on view mode
        function renderMenu(mode = document.getElementById('viewModeSelector')?.value || 'id-tree') {
             currentRenderMode = mode;
             const container = document.getElementById("menu");
             const idControls = document.getElementById("idViewControls");
             const fileControls = document.getElementById("fileViewControls");
             if (!container || !idControls || !fileControls) { console.error("Rendering elements not found."); return; }

             idControls.classList.toggle('d-none', mode === 'file-browser' || mode === 'file-search');
             fileControls.classList.toggle('d-none', mode !== 'file-browser' && mode !== 'file-search');

             // Keep the info message, clear other content in the main menu div
             const infoMsgHtml = infoMessageDiv ? infoMessageDiv.outerHTML : '';
             container.innerHTML = infoMsgHtml;

             // Hide duplicate results area when rendering anything else
             if (duplicateResultsArea) duplicateResultsArea.classList.add('d-none');


             const hasQuestions = Object.keys(rawData).length > 0;
             const hasFiles = loadedFiles.length > 0;

             if (!hasQuestions && !hasFiles) {
                 container.style.display = 'none';
                 if(initialMessageDiv) initialMessageDiv.style.display = 'block';
                 if(infoMessageDiv) infoMessageDiv.classList.add('d-none');
                 return;
             }

             container.style.display = 'block';
             if(initialMessageDiv) initialMessageDiv.style.display = 'none';
             if(infoMessageDiv) infoMessageDiv.classList.remove('d-none');


             if (mode === 'file-browser' || mode === 'file-search') {
                  renderFolderBrowser();
             } else { // 'id-tree' or 'search'
                  renderIDTreeOrSearchResults();
             }

             restoreSelections();
             addFileViewListeners();

         }

         // MODIFICATION: Render function for ID Tree or Search Results
         function renderIDTreeOrSearchResults() {
             const searchBox = document.getElementById("searchBox");
             const searchVal = searchBox ? searchBox.value.trim() : '';
             const queryTerms = searchVal.split(/[\s,]+/).filter(Boolean);
             const typeFilterSelect = document.getElementById("typeFilter");
             const typeFilter = typeFilterSelect ? typeFilterSelect.value : 'all';
             const container = document.getElementById("menu");

             const infoMsgHtml = infoMessageDiv ? infoMessageDiv.outerHTML : '';
             container.innerHTML = infoMsgHtml;

             if (Object.keys(rawData).length === 0) {
                  if(infoMessageDiv) {
                       const bankMapLoaded = Object.keys(globalPredefinedIdMap).length > 0;
                       if (bankMapLoaded) {
                            infoMessageDiv.textContent = `ƒê√£ t·∫£i ${totalDbQuestionCount} ID v√† ${totalDbFileCount} file t·ª´ cache. Kh√¥ng c√≥ ID c√¢u h·ªèi n√†o kh·ªõp v·ªõi bank.json.`;
                       } else {
                           infoMessageDiv.textContent = `ƒê√£ t·∫£i ${totalDbQuestionCount} ID v√† ${totalDbFileCount} file t·ª´ cache. Kh√¥ng c√≥ ID n√†o trong cache c·ª•c b·ªô.`;
                       }
                       infoMessageDiv.classList.remove('d-none');
                    }
                 container.innerHTML += "<p class='text-info fst-italic'>Kh√¥ng c√≥ ID c·∫•u tr√∫c n√†o ph√π h·ª£p v·ªõi bank.json ho·∫∑c b·ªô l·ªçc hi·ªán t·∫°i.</p>";
                 return;
             }


             const isSearchingOrFiltering = queryTerms.length > 0 || typeFilter !== 'all';
             currentRenderMode = isSearchingOrFiltering ? 'search' : 'id-tree';


             if (currentRenderMode === 'search') {
                 renderSearchResults(rawData, queryTerms, typeFilter);
             } else {
                 const tree = buildIDTree(rawData, typeFilter);
                 if (Object.keys(tree).length === 0 || (Object.keys(tree).length === 1 && tree.hasOwnProperty('__ids') && tree.__ids.length === 0)) {
                      if(infoMessageDiv) {
                            const totalFilteredIds = Object.keys(rawData).length;
                           infoMessageDiv.textContent = ``;//ƒê√£ t·∫£i ${totalDbQuestionCount} ID v√† ${totalDbFileCount} file t·ª´ cache (hi·ªÉn th·ªã ${totalFilteredIds} ID kh·ªõp bank.json). Kh√¥ng c√≥ ID n√†o kh·ªõp v·ªõi b·ªô l·ªçc lo·∫°i hi·ªán t·∫°i.
                           infoMessageDiv.classList.remove('d-none');
                      }
                     container.innerHTML += "<p class='text-info fst-italic'>Kh√¥ng c√≥ ID c·∫•u tr√∫c n√†o ph√π h·ª£p v·ªõi b·ªô l·ªçc lo·∫°i hi·ªán t·∫°i.</p>";
                 } else {
                      container.appendChild(renderIDTree(tree, 0));
                       const totalFilteredIds = Object.keys(rawData).length;
                       const bankMapLoaded = Object.keys(globalPredefinedIdMap).length > 0;

                       if(infoMessageDiv) {
                            if (bankMapLoaded) {
                                infoMessageDiv.textContent = `ƒê√£ t·∫£i ${totalDbQuestionCount} ID v√† ${totalDbFileCount} file t·ª´ cache. Hi·ªÉn th·ªã ${totalFilteredIds} ID kh·ªõp v·ªõi bank.json v√† b·ªô l·ªçc.`;
                            } else {
                                 infoMessageDiv.textContent = `L∆∞u √Ω: bank.json kh√¥ng t·∫£i ƒë∆∞·ª£c ho·∫∑c tr·ªëng. Hi·ªÉn th·ªã T·∫§T C·∫¢ ${totalFilteredIds} ID trong cache (kh·ªõp b·ªô l·ªçc).`;
                            }
                            infoMessageDiv.classList.remove('d-none');
                       }
                 }
             }
         }

        // Build ID tree from filtered rawData
        function buildIDTree(data, typeFilter = 'all') { /* ... (no changes needed to logic) ... */
            const root = {};
            for (const id in data) {
                if (!Object.prototype.hasOwnProperty.call(data, id)) continue;
                const item = data[id];
                if (!item || !item.stats) continue;

                const matchesTypeFilter = typeFilter === 'all' ||
                                     (typeFilter === 'choice' && item.stats.choice > 0) ||
                                     (typeFilter === 'choiceTF' && item.stats.choiceTF > 0) ||
                                     (typeFilter === 'other' && item.stats.other > 0);
                if (!matchesTypeFilter) continue;

                const displayDesc = item.desc || 'Ch∆∞a ph√¢n lo·∫°i';
                const path = displayDesc.split("|").map(p => p.trim()).filter(Boolean);
                if (path.length === 0) path.push("Ch∆∞a ph√¢n lo·∫°i");

                let node = root;
                path.forEach((seg, i) => {
                     const isLeafSegment = (i === path.length - 1);
                     const segmentKey = seg;
                     if (!node[segmentKey]) {
                          node[segmentKey] = isLeafSegment ? { __ids: [] } : {};
                     } else if (isLeafSegment && !node[segmentKey].hasOwnProperty('__ids')) {
                           node[segmentKey].__ids = node[segmentKey].__ids || [];
                     }
                     node = node[segmentKey];
                });
                if (node && node.hasOwnProperty('__ids') && !node.__ids.some(existing => existing.id === item.id)) {
                     node.__ids.push(item);
                }
            }
            return root;
         }

        // Render ID tree
        function renderIDTree(node, level = 0) { /* ... (no changes needed) ... */
            const fragment = document.createDocumentFragment();
            const ul = document.createElement("ul");
            ul.className = `level-${level}`;

            const keys = Object.keys(node).sort((a, b) => {
                 const isIdsA = a === "__ids"; const isIdsB = b === "__ids"; const isFolderA = !isIdsA; const isFolderB = !isIdsB;
                 if (isFolderA && isIdsB) return -1; if (isIdsA && isFolderB) return 1;
                 if (isFolderA && isFolderB) return a.localeCompare(b); return 0;
             });

            keys.forEach(key => {
                 if (key === "__ids" && node.__ids && Array.isArray(node.__ids)) {
                     node.__ids.sort((a, b) => a.id.localeCompare(b.id));
                     node.__ids.forEach(item => {
                          const stats = item.stats || { choice: 0, choiceTF: 0, other: 0 };
                          const total = stats.choice + stats.choiceTF + stats.other;
                          if (total === 0) return;

                          const li = document.createElement("li"); li.className = "id-leaf"; li.id = `item-${escapeHtmlAttribute(item.id)}`;

                          const idLineContainer = document.createElement('div');
                          idLineContainer.style.display = 'flex';
                          idLineContainer.style.alignItems = 'center';

                          const idSpanContainer = document.createElement('span');
                          idSpanContainer.style.flexGrow = '1';
                          idSpanContainer.style.cursor = 'pointer';

                          const idSpan = document.createElement("span");
                          let statsHtml = [];
                          if (stats.choice > 0) statsHtml.push(`<span class='choice'>TN:${stats.choice}</span>`);
                          if (stats.choiceTF > 0) statsHtml.push(`<span class='choiceTF'>ƒêS:${stats.choiceTF}</span>`);
                          if (stats.other > 0) statsHtml.push(`<span class='other'>TLN:${stats.other}</span>`);
                          idSpan.innerHTML = `üìò ${escapeHtml(item.id)} (${total}) [${statsHtml.join(',') || 'Tr·ªëng'}]`;
                          idSpan.title = item.desc || 'Kh√¥ng c√≥ di·ªÖn gi·∫£i';

                          idSpanContainer.appendChild(idSpan);
                          idSpanContainer.addEventListener('click', (e) => { e.stopPropagation(); toggleEx(li, item.id); });

                          idLineContainer.appendChild(idSpanContainer);

                          const delIdBtn = document.createElement('button'); delIdBtn.className = 'action-btn btn-delete'; delIdBtn.innerHTML = '<i class="bi bi-trash"></i>'; delIdBtn.title = `X√≥a ID ${escapeHtmlAttribute(item.id)} kh·ªèi cache c·ª•c b·ªô`; delIdBtn.type = 'button';
                          delIdBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteIdEntry(item.id); });
                          idLineContainer.appendChild(delIdBtn);

                          li.appendChild(idLineContainer);

                          if (item.sourceFiles && item.sourceFiles.length > 0) {
                              const sourceDiv = document.createElement('div');
                              sourceDiv.className = 'source-file-info';
                              const sourceLinks = item.sourceFiles.map(filePath =>
                                  `<a href="#" class="view-file-link" data-filepath="${escapeHtmlAttribute(filePath)}" title="Xem n·ªôi dung file ${escapeHtmlAttribute(filePath)}">${escapeHtml(filePath)}</a>`
                              ).join('<br>');
                              sourceDiv.innerHTML = ``;//Ngu·ªìn: ${sourceLinks}
                              li.appendChild(sourceDiv);
                          }

                          const selectionContainer = document.createElement("div"); selectionContainer.className = "selection-container";
                          if (stats.choice > 0) selectionContainer.appendChild(createSelectionGroup(item, "choice", stats.choice));
                          if (stats.choiceTF > 0) selectionContainer.appendChild(createSelectionGroup(item, "choiceTF", stats.choiceTF));
                          if (stats.other > 0) selectionContainer.appendChild(createSelectionGroup(item, "other", stats.other));
                          if (selectionContainer.children.length > 0) { li.appendChild(selectionContainer); }

                          const exContentDiv = document.createElement("div"); exContentDiv.className = "ex-content";
                          exContentDiv.dataset.idContent = item.id;
                          li.appendChild(exContentDiv);

                          fragment.appendChild(li);
                     });
                 } else if (key !== "__ids") {
                      const childNodeData = node[key];
                      const questionCount = countQuestionsInTreeNode(childNodeData);
                      if (questionCount > 0) {
                           const li = document.createElement("li"); li.className = `folder folder-level-${level}`;
                           li.dataset.loaded = "false"; li.dataset.key = key;
                           const folderSpan = document.createElement("span");
                           folderSpan.textContent = `üìÅ ${escapeHtml(key)} (${questionCount})`;
                           folderSpan.title = `M·ªü/ƒë√≥ng: ${escapeHtmlAttribute(key)}`;
                           folderSpan.addEventListener('click', (e) => {
                               e.stopPropagation();
                               li.classList.toggle("open");
                               if (li.classList.contains("open") && li.dataset.loaded === "false") {
                                    console.log(`Lazy loading folder: ${key}`);
                                    showLoading(true, `ƒêang t·∫£i th∆∞ m·ª•c: ${key}...`);
                                    setTimeout(() => {
                                        try {
                                            const childUl = renderIDTree(childNodeData, level + 1);
                                            if (childUl) li.appendChild(childUl);
                                            li.dataset.loaded = "true";
                                            addFileViewListeners(li);
                                        } catch (renderError) { console.error(`Error lazy loading folder ${key}:`, renderError); li.innerHTML += `<p class="text-danger small ms-4">L·ªói t·∫£i th∆∞ m·ª•c con.</p>`; li.dataset.loaded = "error"; }
                                        finally { showLoading(false); }
                                    }, 10);
                               }
                           });
                           li.appendChild(folderSpan);
                           fragment.appendChild(li);
                      }
                 }
            });

             if (fragment.children.length > 0) {
                 ul.appendChild(fragment);
                 return ul;
            } else {
                 return null;
            }
         }

        // Counts questions based on STATS
        function countQuestionsInTreeNode(node) { /* ... (no changes needed) ... */
             let count = 0;
             if (node.__ids) {
                 node.__ids.forEach(item => {
                     if (item && item.stats) { count += (item.stats.choice || 0) + (item.stats.choiceTF || 0) + (item.stats.other || 0); }
                 });
             }
             Object.keys(node).filter(k => k !== "__ids").forEach(key => {
                 if (Object.prototype.hasOwnProperty.call(node, key)) { count += countQuestionsInTreeNode(node[key]); }
             });
             return count;
         }

        // Render search results (iterates over FILTERED rawData)
        async function renderSearchResults(data, searchTerms, typeFilter = 'all') { /* ... (no changes needed) ... */
            const container = document.getElementById("menu");
             const infoMsgHtml = infoMessageDiv ? infoMessageDiv.outerHTML : '';
             container.innerHTML = infoMsgHtml + `<h5 class='mb-3'>K·∫øt qu·∫£ t√¨m ki·∫øm...</h5>`;

             const fragment = document.createDocumentFragment();

            const results = [];
            const searchTermsLower = searchTerms.map(term => term.toLowerCase());
            let fetchPromises = [];

            for (const id in data) {
                if (!Object.prototype.hasOwnProperty.call(data, id)) continue;
                 const item = data[id];
                 if (!item) continue;

                 const desc = item.desc || '';
                 const itemIdLower = id.toLowerCase();
                 const descLower = desc.toLowerCase();

                 let matchesIdDesc = false;
                 if (searchTerms.length > 0) { matchesIdDesc = searchTermsLower.every(termLower => itemIdLower.includes(termLower) || descLower.includes(termLower)); }
                 else { matchesIdDesc = true; }

                 const matchesFilterByType = typeFilter === 'all' || (typeFilter === 'choice' && item.stats?.choice > 0) || (typeFilter === 'choiceTF' && item.stats?.choiceTF > 0) || (typeFilter === 'other' && item.stats?.other > 0);

                 if (matchesFilterByType && (matchesIdDesc || (searchTerms.length > 0 || typeFilter !== 'all'))) {
                       let blocksToSearch = item.exList;
                       let needsContentCheck = searchTerms.length > 0 || typeFilter !== 'all';

                       if (blocksToSearch === null && needsContentCheck) {
                            console.log(`Search/Filter requires fetching exList for ${id}`);
                            fetchPromises.push(fetchExListIfNeeded(id).then(list => ({ id, list })));
                            continue;
                       } else if (Array.isArray(blocksToSearch)) {
                            processItemForSearchResults(item, blocksToSearch, searchTerms, searchTermsLower, typeFilter, results);
                       }
                 }
            }

             if (fetchPromises.length > 0) {
                showLoading(true, `ƒêang t·∫£i n·ªôi dung cho ${fetchPromises.length} ID ƒë·ªÉ t√¨m ki·∫øm/l·ªçc...`);
                try {
                    const fetchedResults = await Promise.all(fetchPromises);
                    fetchedResults.forEach(fetched => {
                        if (fetched.list && rawData[fetched.id]) {
                             processItemForSearchResults(rawData[fetched.id], fetched.list, searchTerms, searchTermsLower, typeFilter, results);
                        }
                    });
                } catch (fetchError) { console.error("Error fetching exLists for search/filter:", fetchError); Swal.fire("L·ªói", "Kh√¥ng th·ªÉ t·∫£i n·ªôi dung ƒë·∫ßy ƒë·ªß ƒë·ªÉ t√¨m ki·∫øm.", "error"); }
                finally { showLoading(false); }
            }

            if (results.length === 0) { container.innerHTML += "<p class='text-info fst-italic'>Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ph√π h·ª£p.</p>"; return; }
            results.sort((a, b) => a.id.localeCompare(b.id) || a.idx - b.idx);
            const resultCountP = document.createElement('p'); resultCountP.className = 'text-muted small'; resultCountP.textContent = `T√¨m th·∫•y ${results.length} block.`; fragment.appendChild(resultCountP);

            results.forEach((result) => {
                 const resultBox = document.createElement("div"); resultBox.className = `ex-box ${result.typeClass} mb-3`;
                 const header = document.createElement('p'); header.className = 'mb-1 small text-muted';
                 header.innerHTML = `ID: ${highlightText(result.id, searchTerms)} | Di·ªÖn gi·∫£i: ${highlightText(result.desc, searchTerms)} | Block: ${result.idx + 1} | Lo·∫°i: ${result.typeName}`;
                 resultBox.appendChild(header);
                 const pre = document.createElement('pre'); const rawLatexContent = result.ex; pre.innerHTML = highlightText(rawLatexContent, searchTerms);

                 const actionButtons = document.createElement('div'); actionButtons.className = 'block-actions'; const escapedLatex = escapeHtmlAttribute(rawLatexContent);
                 const getBtn = document.createElement("button"); getBtn.className = "action-btn btn-get"; getBtn.innerHTML = '<i class="bi bi-plus-circle"></i>'; getBtn.title = "L·∫•y Block"; getBtn.type="button"; getBtn.dataset.latex = escapedLatex; getBtn.dataset.id = result.id; getBtn.dataset.index = result.idx; getBtn.addEventListener('click', (e) => { e.stopPropagation(); grabBlockContent(getBtn); }); actionButtons.appendChild(getBtn);
                 const cBtn = document.createElement("button"); cBtn.className = "action-btn btn-copy"; cBtn.innerHTML = '<i class="bi bi-clipboard"></i>'; cBtn.title = "Copy Block"; cBtn.type="button"; cBtn.dataset.latex = escapedLatex; cBtn.addEventListener('click', (e) => { e.stopPropagation(); copyText(cBtn); }); actionButtons.appendChild(cBtn);
                 const eBtn = document.createElement("button"); eBtn.className = "action-btn btn-edit"; eBtn.innerHTML = '<i class="bi bi-pencil-square"></i>'; eBtn.title = "S·ª≠a Block (C·ª•c b·ªô)"; eBtn.type="button"; eBtn.addEventListener('click', (e) => { e.stopPropagation(); openEditModal(result.id, result.idx); }); actionButtons.appendChild(eBtn);
                 const dBtn = document.createElement("button"); dBtn.className = "action-btn btn-delete"; dBtn.innerHTML = '<i class="bi bi-trash"></i>'; dBtn.title = "X√≥a Block (C·ª•c b·ªô)"; dBtn.type="button"; dBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteBlock(result.id, result.idx); }); actionButtons.appendChild(dBtn);


                 resultBox.appendChild(pre); resultBox.appendChild(actionButtons);
                 fragment.appendChild(resultBox);
            });
            container.appendChild(fragment);
         }

        // Helper for search results
        function processItemForSearchResults(item, exList, searchTerms, searchTermsLower, typeFilter, resultsArray) { /* ... (no changes needed) ... */
             const desc = item.desc || '';
             const itemIdLower = item.id.toLowerCase();
             const descLower = desc.toLowerCase();

             exList.forEach((ex, idx) => {
                 const exLower = ex.toLowerCase();
                 const textToSearchLower = `${itemIdLower} ${descLower} ${exLower}`;
                 const blockTypeClass = getBlockTypeClass(ex);

                 const matchesBlockTypeFilter = typeFilter === 'all' ||
                                             (typeFilter === 'choice' && blockTypeClass === 'ex-choice') ||
                                             (typeFilter === 'choiceTF' && blockTypeClass === 'ex-choiceTF') ||
                                             (typeFilter === 'other' && blockTypeClass === 'ex-other');

                 const matchesSearch = searchTermsLower.length === 0 || searchTermsLower.every(termLower => textToSearchLower.includes(termLower));

                 if (matchesBlockTypeFilter && matchesSearch) {
                      resultsArray.push({ id: item.id, desc: desc, ex: ex, idx: idx, typeClass: blockTypeClass, typeName: getBlockTypeName(ex) });
                  }
             });
         }


        // Creates selection group based on STATS
        function createSelectionGroup(item, type, availableQty) {
            const currentAvailable = rawData[item.id]?.stats?.[type] ?? availableQty ?? 0;

            const groupDiv = document.createElement("div"); groupDiv.className = "form-check form-check-inline align-items-center";
            const checkboxId = `chk-${escapeHtmlAttribute(item.id)}-${escapeHtmlAttribute(type)}`;
            const checkbox = document.createElement("input"); checkbox.type = "checkbox"; checkbox.className = "form-check-input me-1"; checkbox.id = checkboxId; checkbox.value = type;
             checkbox.dataset.id = item.id; checkbox.dataset.type = type;
            const label = document.createElement("label"); label.className = `form-check-label me-1 ${type}`; label.htmlFor = checkboxId;
             let typeLabel = type; if (type === "choice") typeLabel = `TN`; else if (type === "choiceTF") typeLabel = `ƒêS`; else if (type === "other") typeLabel = `TLN`;
            label.innerHTML = `${escapeHtml(typeLabel)}(${currentAvailable})`;
            const qtyInput = document.createElement("input"); qtyInput.type = "number"; qtyInput.className = "form-control qty-input"; qtyInput.placeholder = "#"; qtyInput.min = "1"; qtyInput.max = currentAvailable; qtyInput.disabled = true;
            qtyInput.dataset.id = item.id; qtyInput.dataset.type = type;

            checkbox.addEventListener('change', () => {
                 const id = checkbox.dataset.id;
                 const type = checkbox.dataset.type;
                 const isChecked = checkbox.checked; qtyInput.disabled = !isChecked;
                 const currentAvailable = rawData[id]?.stats?.[type] ?? 0; qtyInput.max = currentAvailable;
                 let currentVal = parseInt(qtyInput.value); let finalQty = 0;
                 if (isChecked) { finalQty = (isNaN(currentVal) || currentVal < 1) ? 1 : Math.min(currentVal, currentAvailable); qtyInput.value = finalQty; }
                 else { qtyInput.value = ''; finalQty = 0; }
                 updateSelection(id, type, isChecked, finalQty, rawData[id]?.desc, currentAvailable);
                 updateSelectedIDsTable();
            });
            qtyInput.addEventListener('input', () => {
                 if (qtyInput.disabled) return;
                 const id = qtyInput.dataset.id;
                 const type = qtyInput.dataset.type;
                 const currentAvailable = rawData[id]?.stats?.[type] ?? 0; qtyInput.max = currentAvailable;
                 let value = parseInt(qtyInput.value); let finalQty = 0;
                 if (isNaN(value) || value < 1) { qtyInput.value = 1; finalQty = 1; }
                 else if (value > currentAvailable) { qtyInput.value = currentAvailable; finalQty = currentAvailable; }
                 else { finalQty = value; }
                 if (finalQty > 0 && !checkbox.checked) { checkbox.checked = true; qtyInput.disabled = false; }
                 else if (finalQty === 0 && checkbox.checked) { checkbox.checked = false; qtyInput.disabled = true; }
                 updateSelection(id, type, checkbox.checked, finalQty, rawData[id].desc, currentAvailable);
                 updateSelectedIDsTable();
            });
            groupDiv.appendChild(checkbox); groupDiv.appendChild(label); groupDiv.appendChild(qtyInput); return groupDiv;
         }
         function updateSelection(id, type, isChecked, quantity, desc, availableQty) { /* ... (no changes needed) ... */
             const currentAvailable = rawData[id]?.stats?.[type] ?? availableQty ?? 0; let validQuantity = parseInt(quantity); if (isNaN(validQuantity) || validQuantity < 0) { validQuantity = 0; } validQuantity = Math.min(validQuantity, currentAvailable); let entry = selectedIDs.get(id); if (isChecked && validQuantity > 0) { if (!entry) { const currentDesc = rawData[id]?.desc || desc || 'N/A'; entry = { desc: currentDesc, choice: 0, choiceTF: 0, other: 0 }; selectedIDs.set(id, entry); } entry[type] = validQuantity; } else { if (entry) { entry[type] = 0; if (entry.choice === 0 && entry.choiceTF === 0 && entry.other === 0) { selectedIDs.delete(id); } } }
         }
        function updateSelectedIDsTable() { /* ... (no changes needed) ... */
             const container = document.getElementById('selectedIDsTable'); if (!container) return; if (selectedIDs.size === 0) { container.innerHTML = ''; return; } let tableHtml = `<h5 class='mt-4'>üìä C√¢u ƒë√£ ch·ªçn</h5><table class='table table-sm table-bordered table-striped caption-top'><caption class="small text-muted">T·ªïng h·ª£p c√¢u h·ªèi ƒë√£ ch·ªçn</caption><thead class='table-light'><tr><th>ID</th><th>Di·ªÖn gi·∫£i</th><th>SL</th><th>Lo·∫°i</th></tr></thead><tbody>`; const sortedEntries = Array.from(selectedIDs.entries()).sort((a, b) => a[0].localeCompare(b[0])); let totalSelected = 0; sortedEntries.forEach(([id, selection]) => {
                  const displayDesc = rawData[id]?.desc || selection.desc || 'N/A';
                 if (selection.choice > 0) { tableHtml += `<tr><td>${escapeHtml(id)}</td><td>${escapeHtml(displayDesc)}</td><td>${selection.choice}</td><td class='choice'>TN</td></tr>`; totalSelected += selection.choice; } if (selection.choiceTF > 0) { tableHtml += `<tr><td>${escapeHtml(id)}</td><td>${escapeHtml(displayDesc)}</td><td>${selection.choiceTF}</td><td class='choiceTF'>ƒêS</td></tr>`; totalSelected += selection.choiceTF; } if (selection.other > 0) { tableHtml += `<tr><td>${escapeHtml(id)}</td><td>${escapeHtml(displayDesc)}</td><td>${selection.other}</td><td class='other'>TLN</td></tr>`; totalSelected += selection.other; } }); tableHtml += `</tbody><tfoot class="table-light"><tr><td colspan="2" class="text-end fw-bold">T·ªïng s·ªë c√¢u/ƒë·ªÅ:</td><td colspan="2" class="fw-bold">${totalSelected}</td></tr></tfoot></table>`; container.innerHTML = tableHtml;
         }

        function clearSelections() { /* ... (no changes needed) ... */
             if (selectedIDs.size === 0) { Swal.fire('Kh√¥ng c√≥ c√¢u h·ªèi n√†o ƒë∆∞·ª£c ch·ªçn', '', 'info'); return; } Swal.fire({ title: 'B·ªè ch·ªçn t·∫•t c·∫£?', icon: 'question', showCancelButton: true, confirmButtonColor: '#d33', confirmButtonText: 'ƒê·ªìng √Ω' }).then((result) => { if (result.isConfirmed) { selectedIDs.clear(); document.querySelectorAll('#menu input[type="checkbox"][id^="chk-"]').forEach(checkbox => { if (checkbox.checked) { checkbox.checked = false; const qtyInput = checkbox.closest('.form-check-inline')?.querySelector('.qty-input'); if (qtyInput) { qtyInput.value = ''; qtyInput.disabled = true; } } }); updateSelectedIDsTable(); document.getElementById('mockResult').innerHTML = ''; console.log("Selections cleared."); Swal.fire('ƒê√£ b·ªè ch·ªçn!', '', 'success'); } });
        }

        // Restore selections based on the currently filtered rawData
        function restoreSelections() { /* ... (no changes needed) ... */
             let changesMade = false;
              document.querySelectorAll('#menu input[type="checkbox"][id^="chk-"]').forEach(checkbox => {
                   const id = checkbox.dataset.id;
                   const type = checkbox.dataset.type;
                   const qtyInput = checkbox.closest('.form-check-inline')?.querySelector('.qty-input');
                   if (!id || !type || !qtyInput || !rawData[id]) {
                        if (checkbox.checked) {
                            checkbox.checked = false;
                            qtyInput.value = '';
                            qtyInput.disabled = true;
                            console.warn(`Deselecting ${id}-${type}: ID not found in filtered rawData.`);
                            changesMade = true;
                        }
                         if (selectedIDs.has(id)) {
                              const selection = selectedIDs.get(id);
                              selection[type] = 0;
                              if (selection.choice === 0 && selection.choiceTF === 0 && selection.other === 0) {
                                  selectedIDs.delete(id);
                              }
                              changesMade = true;
                         }
                         return;
                   }

                   const selection = selectedIDs.get(id);
                   const selectedQty = selection?.[type] || 0;
                   const currentAvailableQty = rawData[id].stats?.[type] || 0;

                   const label = checkbox.closest('.form-check-inline')?.querySelector('label.form-check-label');
                   if (label) { let typeLabel = type; if (type === "choice") typeLabel = `TN`; else if (type === "choiceTF") typeLabel = `ƒêS`; else if (type === "other") typeLabel = `TLN`; label.innerHTML = `${escapeHtml(typeLabel)}(${currentAvailableQty})`; }

                   qtyInput.max = currentAvailableQty;

                   if (selectedQty > 0 && currentAvailableQty > 0) {
                        const clampedQty = Math.min(selectedQty, currentAvailableQty);
                        checkbox.checked = true; qtyInput.value = clampedQty; qtyInput.disabled = false;
                        if (clampedQty !== selectedQty) { console.warn(`Clamped selection ${id}-${type}: ${selectedQty} -> ${clampedQty}`); updateSelection(id, type, true, clampedQty, rawData[id].desc, currentAvailableQty); changesMade = true; }
                   } else {
                        checkbox.checked = false; qtyInput.value = ''; qtyInput.disabled = true;
                        if (selectedQty > 0 && currentAvailableQty === 0) { console.warn(`Removing selection ${id}-${type}: No blocks available.`); updateSelection(id, type, false, 0, rawData[id].desc, 0); changesMade = true; }
                   }
              });

               const idsToDeleteFromSelections = [];
               selectedIDs.forEach((selection, id) => {
                   if (!rawData[id]) {
                       idsToDeleteFromSelections.push(id);
                       changesMade = true;
                       console.warn(`Removing selection for ID ${id}: ID not found in filtered rawData.`);
                   }
               });
               idsToDeleteFromSelections.forEach(id => selectedIDs.delete(id));

              if (selectedIDs.size > 0 || changesMade) { updateSelectedIDsTable(); } else if (selectedIDs.size === 0) { updateSelectedIDsTable(); }
         }


        // Handles lazy loading of exList before rendering block content
        async function toggleEx(liElement, id) { /* ... (no changes needed) ... */
             const exContentDiv = liElement?.querySelector(".ex-content");
             if (!exContentDiv || !id) return;
             const isOpen = exContentDiv.style.display === "block";
             if (isOpen) { exContentDiv.style.display = "none"; }
             else {
                 exContentDiv.style.display = "block"; exContentDiv.innerHTML = ''; exContentDiv.classList.add('loading');
                 try {
                     await fetchExListIfNeeded(id);
                     exContentDiv.classList.remove('loading');
                     const exList = rawData[id]?.exList;
                     if (Array.isArray(exList) && exList.length > 0) { renderExContent(exContentDiv, id, exList); }
                     else { exContentDiv.innerHTML = "<p class='text-muted small fst-italic'>Kh√¥ng c√≥ n·ªôi dung block ho·∫∑c l·ªói t·∫£i.</p>"; }
                 } catch (error) { console.error(`Error fetching/rendering exList for ${id}:`, error); exContentDiv.classList.remove('loading'); exContentDiv.innerHTML = `<p class='text-danger small fst-italic'>L·ªói t·∫£i n·ªôi dung: ${escapeHtml(error.message || error)}</p>`; }
             }
         }

         // Helper to render block content inside ex-content div
        function renderExContent(containerDiv, id, exList) { /* ... (no changes needed) ... */
             containerDiv.innerHTML = ''; const fragment = document.createDocumentFragment();
             if (!Array.isArray(exList)) {
                  containerDiv.innerHTML = "<p class='text-muted small fst-italic'>L·ªói: N·ªôi dung block kh√¥ng h·ª£p l·ªá.</p>";
                  console.error("renderExContent called with non-array exList for ID:", id, exList);
                  return;
             }
             const currentTypeFilter = document.getElementById("typeFilter")?.value || 'all';

             exList.forEach((blockContent, originalIndex) => {
                  const blockTypeClass = getBlockTypeClass(blockContent);
                  const matchesCurrentFilter = currentRenderMode === 'search' || currentTypeFilter === 'all' ||
                                             (currentTypeFilter === 'choice' && blockTypeClass === 'ex-choice') ||
                                             (currentTypeFilter === 'choiceTF' && blockTypeClass === 'ex-choiceTF') ||
                                             (currentTypeFilter === 'other' && blockTypeClass === 'ex-other');

                  if (!matchesCurrentFilter) { return; }


                  const exBox = document.createElement("div"); exBox.className = `ex-box ${blockTypeClass}`; exBox.dataset.index = originalIndex;
                  const pre = document.createElement('pre'); pre.textContent = blockContent;
                  const actionButtons = document.createElement('div'); actionButtons.className = 'block-actions'; const escapedLatex = escapeHtmlAttribute(blockContent);
                  const getBtn = document.createElement("button"); getBtn.className = "action-btn btn-get"; getBtn.innerHTML = '<i class="bi bi-plus-circle"></i>'; getBtn.title = "L·∫•y Block"; getBtn.type="button"; getBtn.dataset.latex = escapedLatex; getBtn.dataset.id = id; getBtn.dataset.index = originalIndex; getBtn.addEventListener('click', (e) => { e.stopPropagation(); grabBlockContent(getBtn); }); actionButtons.appendChild(getBtn);
                  const cBtn = document.createElement("button"); cBtn.className = "action-btn btn-copy"; cBtn.innerHTML = '<i class="bi bi-clipboard"></i>'; cBtn.title = "Copy Block"; cBtn.type="button"; cBtn.dataset.latex = escapedLatex; cBtn.addEventListener('click', (e) => { e.stopPropagation(); copyText(cBtn); }); actionButtons.appendChild(cBtn);
                  const eBtn = document.createElement("button"); eBtn.className = "action-btn btn-edit"; eBtn.innerHTML = '<i class="bi bi-pencil-square"></i>'; eBtn.title = "S·ª≠a Block (C·ª•c b·ªô)"; eBtn.type="button"; eBtn.addEventListener('click', (e) => { e.stopPropagation(); openEditModal(id, originalIndex); }); actionButtons.appendChild(eBtn);
                  const dBtn = document.createElement("button"); dBtn.className = "action-btn btn-delete"; dBtn.innerHTML = '<i class="bi bi-trash"></i>'; dBtn.title = "X√≥a Block (C·ª•c b·ªô)"; dBtn.type="button"; dBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteBlock(id, originalIndex); }); actionButtons.appendChild(dBtn);
                  exBox.appendChild(pre); exBox.appendChild(actionButtons); fragment.appendChild(exBox);
             });
             if (fragment.children.length === 0 && exList.length > 0) {
                  containerDiv.innerHTML = "<p class='text-info small fst-italic'>Kh√¥ng c√≥ block n√†o ph√π h·ª£p v·ªõi b·ªô l·ªçc lo·∫°i hi·ªán t·∫°i.</p>";
             } else if (fragment.children.length === 0 && exList.length === 0) {
                  containerDiv.innerHTML = "<p class='text-muted small fst-italic'>Kh√¥ng c√≥ n·ªôi dung block.</p>";
             }
             containerDiv.appendChild(fragment);
         }


        // Local CRUD Functions
        async function openEditModal(id, blockIndex) { /* ... (no changes needed) ... */
             try {
                 await fetchExListIfNeeded(id);
                 const item = rawData?.[id];
                 if (!item || !Array.isArray(item.exList) || blockIndex < 0 || blockIndex >= item.exList.length) { Swal.fire('L·ªói', 'Kh√¥ng t√¨m th·∫•y Block ho·∫∑c d·ªØ li·ªáu ch∆∞a t·∫£i.', 'error'); return; }
                 const blockContent = item.exList[blockIndex];

                 document.getElementById('editModalId').value = id; document.getElementById('editModalBlockIndex').value = blockIndex; document.getElementById('editModalDisplayId').textContent = id; document.getElementById('editModalTextArea').value = blockContent;
                 bootstrap.Modal.getOrCreateInstance(document.getElementById('editModal')).show();
             } catch (error) { console.error("Error opening edit modal:", error); Swal.fire('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu ƒë·ªÉ ch·ªânh s·ª≠a.', 'error'); }
         }

        async function saveEdit() { /* ... (no changes needed) ... */
            const id = document.getElementById('editModalId').value; const blockIndex = parseInt(document.getElementById('editModalBlockIndex').value); const newContentRaw = document.getElementById('editModalTextArea').value;
            if (!id || isNaN(blockIndex) || blockIndex < 0) { Swal.fire('L·ªói', 'Th√¥ng tin kh√¥ng h·ª£p l·ªá.', 'error'); return; }
            try {
                 await fetchExListIfNeeded(id);
                 const item = rawData?.[id];
                 if (!item || !Array.isArray(item.exList) || blockIndex >= item.exList.length) { Swal.fire('L·ªói', 'D·ªØ li·ªáu g·ªëc kh√¥ng t·ªìn t·∫°i ho·∫∑c ch∆∞a t·∫£i.', 'error'); return; }

                const oldContentFormatted = item.exList[blockIndex];
                if (newContentRaw === oldContentFormatted) { Swal.fire('Kh√¥ng c√≥ thay ƒë·ªïi', '', 'info'); bootstrap.Modal.getInstance(document.getElementById('editModal'))?.hide(); return; }

                showLoading(true, 'ƒêang l∆∞u...');
                const oldStats = {...item.stats};
                item.exList[blockIndex] = newContentRaw;
                item.stats = classifyEx(item.exList);

                if (!db) await initDB(); const tx = db.transaction(QUESTION_STORE_NAME, 'readwrite'); const store = tx.objectStore(QUESTION_STORE_NAME); store.put(item);
                await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = e => rej(e.target.error); });

                const liElement = document.getElementById(`item-${escapeHtmlAttribute(id)}`);
                if (liElement) {
                     const exContentDiv = liElement.querySelector('.ex-content');
                     if (exContentDiv && exContentDiv.style.display === 'block') {
                          renderExContent(exContentDiv, id, item.exList);
                     }
                     const idSpan = liElement.querySelector(':scope > div > span > span:first-child');
                      if (idSpan) {
                          const total = item.stats.choice + item.stats.choiceTF + item.stats.other; let statsHtml = [];
                          if (item.stats.choice > 0) statsHtml.push(`<span class='choice'>TN:${item.stats.choice}</span>`);
                          if (item.stats.choiceTF > 0) statsHtml.push(`<span class='choiceTF'>ƒêS:${item.stats.choiceTF}</span>`);
                          if (item.stats.other > 0) statsHtml.push(`<span class='other'>TLN:${item.stats.other}</span>`);
                          idSpan.innerHTML = `üìò ${escapeHtml(id)} (${total}) [${statsHtml.join(',') || 'Tr·ªëng'}]`;
                      }
                     if (JSON.stringify(oldStats) !== JSON.stringify(item.stats)) { restoreSelections(); }
                } else {
                     console.warn(`Could not find list item for ID ${id} to update DOM locally. Re-rendering menu.`);
                     renderMenu();
                }

                 updateSelectedIDsTable();
                 bootstrap.Modal.getInstance(document.getElementById('editModal'))?.hide();
                 Swal.fire('ƒê√£ l∆∞u (C·ª•c b·ªô)', 'Thay ƒë·ªïi ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o cache.', 'success');

            } catch (error) { console.error("Error saveEdit:", error); Swal.fire('L·ªói L∆∞u', `${error.message || error}`, 'error'); loadAllDataAndRenderUI(); }
            finally { showLoading(false); }
        }

        async function deleteBlock(id, blockIndex) { /* ... (no changes needed) ... */
            try { await fetchExListIfNeeded(id); } catch { /* Ignore */ }
             const item = rawData?.[id];
             if (!item || !Array.isArray(item.exList) || blockIndex < 0 || blockIndex >= item.exList.length) { Swal.fire('Th√¥ng b√°o', 'Block kh√¥ng t·ªìn t·∫°i ho·∫∑c ch∆∞a t·∫£i.', 'info'); return; }

             Swal.fire({ title: 'X√≥a block?', text: `X√≥a block ${blockIndex + 1} c·ªßa ID ${escapeHtml(id)} (c·ª•c b·ªô)?`, icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', confirmButtonText: 'X√≥a' })
             .then(async (result) => { if (result.isConfirmed) {
                  showLoading(true, 'ƒêang x√≥a...');
                  try {
                       const oldStats = {...item.stats};
                       item.exList.splice(blockIndex, 1);

                       if (item.exList.length === 0) {
                           await deleteIdEntry(id, true);
                       }
                       else {
                            item.stats = classifyEx(item.exList);
                           if (!db) await initDB(); const tx = db.transaction(QUESTION_STORE_NAME, 'readwrite'); const store = tx.objectStore(QUESTION_STORE_NAME); store.put(item);
                           await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = e => rej(e.target.error); });

                           const liElement = document.getElementById(`item-${escapeHtmlAttribute(id)}`);
                           if (liElement) {
                                const exContentDiv = liElement.querySelector('.ex-content');
                                if (exContentDiv && exContentDiv.style.display === 'block') {
                                    renderExContent(exContentDiv, id, item.exList);
                                }
                                const idSpan = liElement.querySelector(':scope > div > span > span:first-child');
                                if (idSpan) {
                                     const total = item.stats.choice + item.stats.choiceTF + item.stats.other; let statsHtml = [];
                                     if (item.stats.choice > 0) statsHtml.push(`<span class='choice'>TN:${item.stats.choice}</span>`);
                                     if (item.stats.choiceTF > 0) statsHtml.push(`<span class='choiceTF'>ƒêS:${item.stats.choiceTF}</span>`);
                                     if (item.stats.other > 0) statsHtml.push(`<span class='other'>TLN:${item.stats.other}</span>`);
                                     idSpan.innerHTML = `üìò ${escapeHtml(id)} (${total}) [${statsHtml.join(',') || 'Tr·ªëng'}]`;
                                }
                               if (JSON.stringify(oldStats) !== JSON.stringify(item.stats)) { restoreSelections(); }
                           } else {
                                console.warn(`Could not find list item for ID ${id} to update DOM locally after block delete. Re-rendering menu.`);
                                renderMenu();
                           }
                            updateSelectedIDsTable();
                             Swal.fire('ƒê√£ x√≥a block', '', 'success');
                       }
                  } catch (error) { console.error("Error deleteBlock:", error); Swal.fire('L·ªói X√≥a Block', `${error.message || error}`, 'error'); loadAllDataAndRenderUI(); }
                  finally { showLoading(false); }
             }});
         }

        async function deleteIdEntry(id, skipConfirmation = false) { /* ... (no changes needed) ... */
             let idExistsInDb = false;
             try {
                 if (!db) await initDB();
                 const txCheck = db.transaction(QUESTION_STORE_NAME, 'readonly');
                 const storeCheck = txCheck.objectStore(QUESTION_STORE_NAME);
                 const reqCheck = storeCheck.count(id);
                 const countInDb = await new Promise((res, rej) => { reqCheck.onsuccess = (e) => res(e.target.result); reqCheck.onerror = rej; });
                 if (countInDb > 0) idExistsInDb = true;
             } catch (checkError) {
                 console.error("Error checking if ID exists in DB:", checkError);
                 Swal.fire('L·ªói Database', 'Kh√¥ng th·ªÉ ki·ªÉm tra s·ª± t·ªìn t·∫°i c·ªßa ID trong DB.', 'error');
                 return;
             }

             if (!idExistsInDb) {
                 Swal.fire('Th√¥ng b√°o', `ID "${escapeHtml(id)}" kh√¥ng t√¨m th·∫•y trong cache c·ª•c b·ªô.`, 'info');
                 return;
             }
             if (!rawData?.[id]) {
                  console.log(`ID ${id} found in DB but not in current filtered rawData. Proceeding with DB deletion.`);
             }


             const performDelete = async () => {
                  showLoading(true, `ƒêang x√≥a ID ${id} kh·ªèi cache...`);
                  try {
                       const itemWasInRawData = !!rawData[id];
                       const itemWasSelected = selectedIDs.has(id);

                       delete rawData[id];
                       if (itemWasSelected) { selectedIDs.delete(id); }

                       if (!db) await initDB();
                       const tx = db.transaction(QUESTION_STORE_NAME, 'readwrite');
                       const store = tx.objectStore(QUESTION_STORE_NAME);
                       store.delete(id);
                       await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = e => rej(e.target.error); });

                       totalDbQuestionCount--;
                       if (totalDbQuestionCount < 0) totalDbQuestionCount = 0;


                       const liElement = document.getElementById(`item-${escapeHtmlAttribute(id)}`);
                       if (liElement && currentRenderMode !== 'file-browser' && currentRenderMode !== 'file-search') {
                            liElement.remove();
                       } else {
                            console.warn(`List item for ID ${id} not found in current view for direct removal. Re-rendering menu.`);
                             renderMenu();
                       }

                       updateSelectedIDsTable();
                       Swal.fire('ƒê√£ x√≥a ID', `ID ${escapeHtml(id)} ƒë√£ ƒë∆∞·ª£c x√≥a kh·ªèi cache c·ª•c b·ªô. File g·ªëc kh√¥ng b·ªã x√≥a.`, 'success');

                  } catch (error) { console.error(`Error deleting ID ${id}:`, error); Swal.fire('L·ªói X√≥a ID', `${error.message || error}`, 'error'); loadAllDataAndRenderUI(); }
                  finally { showLoading(false); }
              };

             if (skipConfirmation) { await performDelete(); }
             else {
                  const confirmationText = rawData[id] ?
                      `To√†n b·ªô ID <b>${escapeHtml(id)}</b> s·∫Ω b·ªã x√≥a kh·ªèi cache c√¢u h·ªèi c·ª•c b·ªô.` :
                      `ID <b>${escapeHtml(id)}</b> (ƒëang c√≥ trong cache nh∆∞ng kh√¥ng hi·ªÉn th·ªã) s·∫Ω b·ªã x√≥a kh·ªèi cache c√¢u h·ªèi c·ª•c b·ªô.`;

                 Swal.fire({ title: `X√≥a ID ${escapeHtml(id)}?`, html: `${confirmationText} File g·ªëc s·∫Ω kh√¥ng b·ªã x√≥a.`, icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33', confirmButtonText: 'X√≥a' }).then(async (result) => { if (result.isConfirmed) { await performDelete(); } });
             }
         }


        // --- Exam Generation ---
        async function generateMultipleExams() { /* ... (no changes needed) ... */
             const numExamsInput = document.getElementById("numExams"); const nE = parseInt(numExamsInput?.value || '0');
             if (isNaN(nE) || nE <= 0) { Swal.fire('S·ªë ƒë·ªÅ kh√¥ng h·ª£p l·ªá', '...', 'warning'); return; }
             if (selectedIDs.size === 0) { Swal.fire('Ch∆∞a ch·ªçn c√¢u h·ªèi', '...', 'warning'); return; }

             showLoading(true, `ƒêang chu·∫©n b·ªã t·∫°o ${nE} ƒë·ªÅ...`);

             const selectionsForGeneration = [];
             let missingDataError = null;
             let insufficientQuestionsError = null;
             const fetchNeededIds = [];

             for (const [id, selection] of selectedIDs.entries()) {
                 if (!rawData[id]) {
                      missingDataError = `L·ªói: ID "${escapeHtml(id)}" ƒë√£ ƒë∆∞·ª£c ch·ªçn nh∆∞ng kh√¥ng c√≤n trong danh s√°ch hi·ªÉn th·ªã (bank.json). Vui l√≤ng b·ªè ch·ªçn ID n√†y.`;
                      break;
                 }

                 const needsExList = (selection.choice > 0 || selection.choiceTF > 0 || selection.other > 0);

                 if (rawData[id].exList === null && needsExList) {
                      if (!fetchNeededIds.includes(id)) { fetchNeededIds.push(id); }
                 }
             }

             if (missingDataError) { showLoading(false); Swal.fire('L·ªói D·ªØ Li·ªáu', missingDataError, 'error'); return; }

             if (fetchNeededIds.length > 0) {
                  console.log(`Fetching exList for ${fetchNeededIds.length} selected IDs before generating exams...`);
                  showLoading(true, `ƒêang t·∫£i n·ªôi dung cho ${fetchNeededIds.length} c√¢u h·ªèi ƒë√£ ch·ªçn...`);
                  try { await Promise.all(fetchNeededIds.map(id => fetchExListIfNeeded(id))); console.log("Finished fetching exLists for exam generation."); }
                  catch (fetchError) { console.error("Error fetching exLists for exam generation:", fetchError); showLoading(false); Swal.fire('L·ªói T·∫£i D·ªØ Li·ªáu', 'Kh√¥ng th·ªÉ t·∫£i ƒë·∫ßy ƒë·ªß n·ªôi dung c√¢u h·ªèi ƒë·ªÉ t·∫°o ƒë·ªÅ.', 'error'); return; }
                  finally { showLoading(false); }
             }

              for (const [id, selection] of selectedIDs.entries()) {
                 if (insufficientQuestionsError || missingDataError) return;

                 const itemData = rawData[id];
                 if (!itemData || !itemData.stats || !Array.isArray(itemData.exList)) {
                      missingDataError = `L·ªói d·ªØ li·ªáu: N·ªôi dung cho ID "${escapeHtml(id)}" kh√¥ng s·∫µn s√†ng. Vui l√≤ng t·∫£i l·∫°i trang ho·∫∑c x√≥a cache.`;
                      return;
                 }

                 ["choice", "choiceTF", "other"].forEach(type => {
                      const requestedQty = selection[type] || 0;
                      if (requestedQty > 0) {
                           const availableBlocksOfType = itemData.exList.filter(block => {
                                const c = getBlockTypeClass(block);
                                return (type === 'choice' && c === 'ex-choice') ||
                                       (type === 'choiceTF' && c === 'ex-choiceTF') ||
                                       (type === 'other' && c === 'ex-other');
                           });

                           const availableCount = availableBlocksOfType.length;
                           const requiredTotal = requestedQty * nE;

                           if (availableCount < requiredTotal) {
                                const typeName = getBlockTypeName(type === 'choice' ? '\\choice' : type === 'choiceTF' ? '\\choiceTF' : 'other');
                                insufficientQuestionsError = `Kh√¥ng ƒë·ªß c√¢u h·ªèi lo·∫°i ${typeName} cho ID "${escapeHtml(id)}": Ch·ªâ c√≥ ${availableCount} block, c·∫ßn ${requiredTotal} (${requestedQty} c√¢u/ƒë·ªÅ * ${nE} ƒë·ªÅ).`;
                                return;
                           }

                           selectionsForGeneration.push({
                                id: id,
                                type: type,
                                qtyPerExam: requestedQty,
                                availableBlocks: availableBlocksOfType.sort(() => Math.random() - 0.5),
                                currentIndex: 0,
                                desc: itemData.desc || 'N/A'
                           });
                      }
                 });
                 if (insufficientQuestionsError) break;
             }


             if (missingDataError) { showLoading(false); Swal.fire('L·ªói D·ªØ Li·ªáu', missingDataError, 'error'); return; }
             if (insufficientQuestionsError) { showLoading(false); Swal.fire('Kh√¥ng ƒê·ªß C√¢u H·ªèi', insufficientQuestionsError, 'error'); return; }
             if (selectionsForGeneration.length === 0) { showLoading(false); Swal.fire('L·ªói Logic', 'Kh√¥ng c√≥ l·ª±a ch·ªçn h·ª£p l·ªá ƒë·ªÉ t·∫°o ƒë·ªÅ.', 'error'); return; }


             showLoading(true, `ƒêang t·∫°o ${nE} ƒë·ªÅ...`);
             setTimeout(() => {
                 try {
                     const summaryTableRows = selectionsForGeneration.map(sel => { const tN=getBlockTypeName(sel.type==='choice'?'\\choice':sel.type==='choiceTF'?'\\choiceTF':'other'); const tC=sel.type==='choice'?'choice':sel.type==='choiceTF'?'choiceTF':'other'; return `<tr><td>${escapeHtml(sel.id)}</td><td>${escapeHtml(sel.desc)}</td><td>${sel.qtyPerExam}</td><td class="${tC}">${tN}</td></tr>`; }).join('');
                     const totalQ = selectionsForGeneration.reduce((s, sel) => s + sel.qtyPerExam, 0);
                     const summaryTableHtml = `<h5 class='mt-4'>üìä C·∫•u tr√∫c/ƒë·ªÅ</h5><table class='table table-sm table-bordered caption-top'><caption class="small text-muted">T·ªïng ${totalQ} c√¢u/ƒë·ªÅ</caption><thead class='table-light'><tr><th>ID</th><th>Di·ªÖn gi·∫£i</th><th>SL/ƒë·ªÅ</th><th>Lo·∫°i</th></tr></thead><tbody>${summaryTableRows}</tbody></table>`;

                     const examsOutputHtml = [summaryTableHtml];
                     const doReplace = document.getElementById("replaceVdBtCheckbox")?.checked || false;

                     for (let i = 0; i < nE; i++) {
                         let currentExamBlocks = [];
                         selectionsForGeneration.forEach(src => {
                              const sI = src.currentIndex;
                              const eI = sI + src.qtyPerExam;
                              const blocksToDraw = src.availableBlocks.slice(sI, eI);
                              currentExamBlocks.push(...blocksToDraw);
                              src.currentIndex = eI;
                         });
                         currentExamBlocks.sort(() => Math.random() - 0.5);
                         const examLatex = currentExamBlocks.map(b => { let pB=b; if(doReplace){ pB=pB.replace(/\\begin\{(?:vd|bt)\}/g,'\\begin{ex}').replace(/\\end\{(?:vd|bt)\}/g,'\\end{ex}'); } return pB; }).join("\n\n%-----------\n\n");

                         const examTypeClass = currentExamBlocks.some(q=>getBlockTypeClass(q)==='ex-choiceTF')?'ex-choiceTF':(currentExamBlocks.some(q=>getBlockTypeClass(q)==='ex-choice')?'ex-choice':'ex-other');

                         const escapedDisplayLatex = escapeHtml(examLatex);
                         const escapedDataLatex = escapeHtmlAttribute(examLatex);

                         const copyButton = `<button class='btn btn-sm btn-outline-primary mt-2' type="button" data-latex="${escapedDataLatex}" title="Copy ƒê·ªÅ ${i + 1}"><i class="bi bi-clipboard"></i> Copy ƒê·ªÅ ${i+1}</button>`;
                         const examBoxHtml = `<div class='ex-box ${examTypeClass} mb-4'><h5>üìÑ ƒê·ªÅ ${i + 1}</h5><pre>${escapedDisplayLatex}</pre>${copyButton}</div>`;
                         examsOutputHtml.push(examBoxHtml);
                     }

                     const mockResultElement = document.getElementById("mockResult");
                     if (mockResultElement) {
                         mockResultElement.innerHTML = examsOutputHtml.join("");
                         mockResultElement.querySelectorAll('button[data-latex]').forEach(btn => { btn.addEventListener('click', (e) => { e.stopPropagation(); copyText(btn); }); });
                         mockResultElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                     }

                     showLoading(false);
                     Swal.fire('Ho√†n th√†nh', `ƒê√£ t·∫°o ${nE} ƒë·ªÅ.`, 'success');

                 } catch (e) {
                     console.error("L·ªói t·∫°o ƒë·ªÅ:", e);
                     Swal.fire('L·ªói T·∫°o ƒê·ªÅ', `L·ªói: ${e.message || e}`, 'error');
                     showLoading(false);
                     document.getElementById("mockResult").innerHTML = '<p class="text-danger">L·ªói t·∫°o ƒë·ªÅ.</p>';
                 }
             }, 50);
         }

         // --- File Browser View ---

         // Build folder tree structure from file paths
         function buildFolderTree(files) { /* ... (no changes needed) ... */
             const root = {};
             if (!Array.isArray(files)) return root;

             files.forEach(file => {
                 const parts = file.filePath.split('/');
                 let currentNode = root;
                 parts.forEach((part, index) => {
                     const isLastPart = (index === parts.length - 1);
                     if (isLastPart) {
                         if (!currentNode.__files) {
                             currentNode.__files = [];
                         }
                         if (!currentNode.__files.some(f => f.filePath === file.filePath)) {
                             currentNode.__files.push(file);
                         }
                     } else {
                         const folderName = part;
                         if (!currentNode[folderName]) {
                             currentNode[folderName] = {};
                         }
                         currentNode = currentNode[folderName];
                     }
                 });
             });

             const sortNode = (node) => {
                  if (node.__files) {
                       node.__files.sort((a, b) => a.fileName.localeCompare(b.fileName));
                  }
                  const folderKeys = Object.keys(node).filter(key => key !== '__files').sort();
                  folderKeys.forEach(key => {
                       sortNode(node[key]);
                  });
                  const reorderedNode = {};
                  folderKeys.forEach(key => reorderedNode[key] = node[key]);
                  if (node.__files) reorderedNode.__files = node.__files;
                   for (const key in node) delete node[key];
                   Object.assign(node, reorderedNode);

             };

             sortNode(root);

             return root;
         }


         // MODIFICATION: Render folder tree structure (Expandable)
         function renderFolderTree(node, level = 0) { /* ... (no changes needed) ... */
             const fragment = document.createDocumentFragment();
             const ul = document.createElement("ul");
             ul.className = `level-${level}`;

             const folderKeys = Object.keys(node).filter(key => key !== '__files').sort((a, b) => a.localeCompare(b));
             const filesInNode = node.__files || [];

             folderKeys.forEach(folderName => {
                 const childNodeData = node[folderName];
                 if (Object.keys(childNodeData).length > 0 || (childNodeData.__files && childNodeData.__files.length > 0)) {
                     const li = document.createElement("li");
                     li.className = `folder-node folder-level-${level}`;

                     const folderSpan = document.createElement("span");
                     folderSpan.textContent = escapeHtml(folderName);
                     folderSpan.title = `M·ªü/ƒë√≥ng: ${escapeHtmlAttribute(folderName)}`;
                     folderSpan.addEventListener('click', (e) => {
                         e.stopPropagation();
                         li.classList.toggle("open");
                     });
                     li.appendChild(folderSpan);

                     const childUl = renderFolderTree(childNodeData, level + 1);
                     if (childUl) {
                         li.appendChild(childUl);
                     }

                     fragment.appendChild(li);
                 }
             });

             filesInNode.sort((a, b) => a.fileName.localeCompare(b.fileName));
             filesInNode.forEach(file => {
                 const li = document.createElement("li");
                 li.className = "file-item";

                 const fileSpan = document.createElement("span");
                 fileSpan.dataset.filepath = file.filePath;
                 fileSpan.title = `Xem n·ªôi dung file: ${escapeHtmlAttribute(file.filePath)}`;
                 fileSpan.addEventListener('click', handleFileViewClick);

                 const fileNameSpan = document.createElement("span");
                 fileNameSpan.className = "file-path-text";
                 fileNameSpan.textContent = escapeHtml(file.fileName);
                 fileSpan.appendChild(fileNameSpan);


                 li.appendChild(fileSpan);
                 fragment.appendChild(li);
             });


             if (fragment.children.length > 0) {
                 ul.appendChild(fragment);
                 return ul;
            } else {
                 return null;
            }
         }

         // MODIFICATION: Render File Browser
         function renderFolderBrowser() {
              const container = document.getElementById("menu");
              const infoMsgHtml = infoMessageDiv ? infoMessageDiv.outerHTML : '';
              container.innerHTML = infoMsgHtml + `<h5 class='mb-3'>Duy·ªát File ƒê√£ N·∫°p</h5>`;

              const fileSearchBox = document.getElementById("fileSearchBox");
              const searchVal = fileSearchBox ? fileSearchBox.value.trim() : '';
              const queryTerms = searchVal.split(/[\s,]+/).filter(Boolean).map(term => term.toLowerCase());

              let filesToRender = loadedFiles;

              if (queryTerms.length > 0) {
                   currentRenderMode = 'file-search';
                   filesToRender = loadedFiles.filter(file => {
                        const filePathLower = file.filePath.toLowerCase();
                        const fileNameLower = file.fileName.toLowerCase();
                        return queryTerms.every(termLower => filePathLower.includes(termLower) || fileNameLower.includes(termLower));
                   });
                   container.innerHTML += `<p class='text-muted small'>T√¨m th·∫•y ${filesToRender.length} file kh·ªõp v·ªõi t√¨m ki·∫øm.</p>`;
              } else {
                   currentRenderMode = 'file-browser';
                  if (loadedFiles.length > 0) {
                       if(infoMessageDiv) {
                           infoMessageDiv.textContent = `ƒê√£ t·∫£i ${totalDbQuestionCount} ID v√† ${totalDbFileCount} file t·ª´ cache.`;
                           infoMessageDiv.classList.remove('d-none');
                       }
                   } else {
                       if(infoMessageDiv) {
                           infoMessageDiv.textContent = `Kh√¥ng c√≥ file n√†o trong cache c·ª•c b·ªô.`;
                           infoMessageDiv.classList.add('d-none'); // Hide if no files
                       }
                  }
              }


              if (filesToRender.length === 0 && queryTerms.length > 0) {
                  container.innerHTML += "<p class='text-info fst-italic'>Kh√¥ng t√¨m th·∫•y file n√†o kh·ªõp v·ªõi t√¨m ki·∫øm.</p>";
              } else if (filesToRender.length === 0 && queryTerms.length === 0) {
                   // Message handled above, no files at all
              } else {
                   const folderTree = buildFolderTree(filesToRender);
                   const renderedTree = renderFolderTree(folderTree, 0);

                   if (renderedTree) {
                        container.appendChild(renderedTree);
                   } else if (filesToRender.length > 0) {
                         const rootUl = document.createElement("ul"); rootUl.className = "level-0";
                         filesToRender.sort((a, b) => a.fileName.localeCompare(b.fileName));
                         filesToRender.forEach(file => {
                              const li = document.createElement("li"); li.className = "file-item";
                              const fileSpan = document.createElement("span");
                              fileSpan.dataset.filepath = file.filePath;
                              fileSpan.title = `Xem n·ªôi dung file: ${escapeHtmlAttribute(file.filePath)}`;
                              fileSpan.addEventListener('click', handleFileViewClick);
                              const fileNameSpan = document.createElement("span"); fileNameSpan.className = "file-path-text";
                              fileNameSpan.textContent = escapeHtml(file.fileName);
                              fileSpan.appendChild(fileNameSpan);
                              li.appendChild(fileSpan);
                              rootUl.appendChild(li);
                         });
                         container.appendChild(rootUl);
                   }
              }
          }


         // Functions for File View Modal
         function addFileViewListeners(parentElement = document.getElementById('menu')) {
             if (!parentElement) return;
             parentElement.querySelectorAll('[data-filepath]').forEach(link => {
                 if (!link.dataset.listenerAdded) {
                      link.addEventListener('click', handleFileViewClick);
                      link.dataset.listenerAdded = 'true';
                 }
             });
         }

         async function handleFileViewClick(event) {
             event.preventDefault();
             event.stopPropagation();
             const clickableElement = event.target.closest('[data-filepath]');
             if (!clickableElement) {
                 console.error("Clickable element with data-filepath not found starting from target:", event.target);
                 return;
             }
             const filePath = clickableElement.dataset.filepath;
             if (!filePath) {
                 console.error("File path attribute is empty on the clicked element:", clickableElement);
                 return;
             }
             await displayFileContent(filePath);
         }

         // MODIFICATION: Display File Content in Modal (with Find/Highlight/Save state)
         async function displayFileContent(filePath) {
             console.log(`Request to display file: ${filePath}`);
             const modalElement = document.getElementById('fileContentModal');
             const pathElement = document.getElementById('fileContentModalPath');

             if (!modalElement || !fileContentModalPreElement || !pathElement || !copyFileContentBtnElement || !saveFileContentBtnElement || !fileFindInput || !fileFindNextBtn || !fileReplaceInput || !fileReplaceNextBtn || !fileReplaceAllBtn || !fileMatchCountSpan) {
                 console.error("File content modal elements not fully initialized.");
                 Swal.fire('L·ªói Giao Di·ªán', 'Kh√¥ng t√¨m th·∫•y c√°c th√†nh ph·∫ßn c·ªßa modal xem file.', 'error');
                 return;
             }

             if (!fileContentModalInstance) {
                fileContentModalInstance = new bootstrap.Modal(modalElement);
             }

             // Reset modal state
             pathElement.textContent = `ƒêang t·∫£i: ${escapeHtml(filePath)}...`;
             fileContentModalPreElement.textContent = 'ƒêang t·∫£i...';
             modalOriginalFileContent = null;
             modalCurrentFilePath = filePath;
             // Clear Find/Replace state
             modalSearchMatches = [];
             modalCurrentMatchIndex = -1;
             fileFindInput.value = '';
             fileReplaceInput.value = '';
             fileMatchCountSpan.textContent = '';
             clearFileHighlights(); // Ensure any old highlights are gone from the element


             // Disable buttons initially
             copyFileContentBtnElement.disabled = true;
             copyFileContentBtnElement.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> ƒêang t·∫£i...';
             saveFileContentBtnElement.disabled = true;
             fileContentModalPreElement.setAttribute('contenteditable', 'false'); // Disable editing while loading
             fileFindInput.disabled = true;
             fileFindNextBtn.disabled = true;
             fileReplaceInput.disabled = true;
             fileReplaceNextBtn.disabled = true;
             fileReplaceAllBtn.disabled = true;


             modalCurrentFilePath = filePath;

             fileContentModalInstance.show();
             showLoading(true, `ƒêang t·∫£i file: ${filePath}...`);

             try {
                 const content = await getFileContentFromDB(filePath);
                 pathElement.textContent = escapeHtml(filePath);

                 if (content !== null) {
                     modalOriginalFileContent = content;
                     fileContentModalPreElement.textContent = content; // Set raw text content
                     fileContentModalPreElement.setAttribute('contenteditable', 'true'); // Enable editing

                     // Enable relevant UI
                     copyFileContentBtnElement.disabled = false;
                     copyFileContentBtnElement.innerHTML = '<i class="bi bi-clipboard"></i> Copy n·ªôi dung file';
                     saveFileContentBtnElement.disabled = content === modalOriginalFileContent; // Enable only if changed (initially disabled)
                     fileFindInput.disabled = false;
                     fileFindNextBtn.disabled = false;
                     fileReplaceInput.disabled = false;
                     fileReplaceNextBtn.disabled = false; // Will be disabled if no matches
                     fileReplaceAllBtn.disabled = false; // Will be disabled if no matches


                 } else {
                     fileContentModalPreElement.textContent = `*** L·ªói: Kh√¥ng t√¨m th·∫•y n·ªôi dung cho file n√†y trong cache. ***`;
                     fileContentModalPreElement.setAttribute('contenteditable', 'false');
                     copyFileContentBtnElement.disabled = true; copyFileContentBtnElement.innerHTML = '<i class="bi bi-clipboard"></i> Copy n·ªôi dung file';
                     saveFileContentBtnElement.disabled = true;
                     fileFindInput.disabled = true; fileFindNextBtn.disabled = true;
                     fileReplaceInput.disabled = true; fileReplaceNextBtn.disabled = true; fileReplaceAllBtn.disabled = true;
                 }
             } catch (error) {
                 console.error(`Error displaying file content for ${filePath}:`, error);
                 pathElement.textContent = escapeHtml(filePath);
                 fileContentModalPreElement.textContent = `*** L·ªói khi t·∫£i file: ${escapeHtml(error.message || error)} ***`;
                 Swal.fire('L·ªói T·∫£i File', `Kh√¥ng th·ªÉ t·∫£i n·ªôi dung cho file:\n${filePath}`, 'error');
                 fileContentModalPreElement.setAttribute('contenteditable', 'false');
                 copyFileContentBtnElement.disabled = true; copyFileContentBtnElement.innerHTML = '<i class="bi bi-clipboard"></i> Copy n·ªôi dung file';
                 saveFileContentBtnElement.disabled = true;
                 fileFindInput.disabled = true; fileFindNextBtn.disabled = true;
                 fileReplaceInput.disabled = true; fileReplaceNextBtn.disabled = true; fileReplaceAllBtn.disabled = true;

             } finally {
                 showLoading(false);
                  // Re-add listener for input change on the PRE element to track changes and enable save button
                 fileContentModalPreElement.removeEventListener('input', checkFileModalContentChanged);
                 if(fileContentModalPreElement.getAttribute('contenteditable') === 'true') {
                     fileContentModalPreElement.addEventListener('input', checkFileModalContentChanged);
                 }
             }
         }

         // MODIFICATION: Check if content in modal has changed from original
         function checkFileModalContentChanged() {
             if (!modalOriginalFileContent || !saveFileContentBtnElement || !fileContentModalPreElement) return;
             const currentContent = fileContentModalPreElement.textContent;
             // Enable save button only if content is different from original
             saveFileContentBtnElement.disabled = currentContent === modalOriginalFileContent;
         }

         // MODIFICATION: Save File Content from modal
         async function saveFileContent() {
              if (!modalCurrentFilePath || !fileContentModalPreElement || !saveFileContentBtnElement) {
                   console.error("Modal state or elements missing for save.");
                   return;
              }

              const currentContent = fileContentModalPreElement.textContent;
              if (currentContent === modalOriginalFileContent) {
                   Swal.fire('Kh√¥ng c√≥ thay ƒë·ªïi', '', 'info');
                   // Close modal? Or just disable save button? Let's just disable save.
                   saveFileContentBtnElement.disabled = true;
                   return;
              }

              showLoading(true, `ƒêang l∆∞u file: ${modalCurrentFilePath}...`);
              saveFileContentBtnElement.disabled = true;

              try {
                 const result = await addFilesToDB([{ filePath: modalCurrentFilePath, content: currentContent }]);

                 if (result.success > 0) {
                      modalOriginalFileContent = currentContent;
                      Swal.fire('ƒê√£ l∆∞u file (C·ª•c b·ªô)', `N·ªôi dung file "${escapeHtml(modalCurrentFilePath)}" ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o cache. <br><small class="text-muted">L∆∞u √Ω: ƒê·ªÉ c·∫≠p nh·∫≠t danh s√°ch c√¢u h·ªèi theo thay ƒë·ªïi trong file, vui l√≤ng nh·∫•n "üìÇ Th√™m Th∆∞ M·ª•c" v√† ch·ªçn l·∫°i th∆∞ m·ª•c ch·ª©a file n√†y.</small>`, 'success');
                 } else {
                      throw new Error('L·ªói l∆∞u file v√†o DB.');
                 }
              } catch (error) {
                   console.error(`Error saving file ${modalCurrentFilePath}:`, error);
                   Swal.fire('L·ªói L∆∞u File', `Kh√¥ng th·ªÉ l∆∞u n·ªôi dung file: ${error?.message || error}`, 'error');
              } finally {
                   showLoading(false);
                   // Save button remains disabled until content changes again
              }
         }

         // MODIFICATION: Find/Highlight logic in File Modal
         function findInFileContent() {
              if (!fileContentModalPreElement || !fileFindInput || !fileMatchCountSpan || !fileFindNextBtn || !fileReplaceInput || !fileReplaceNextBtn || !fileReplaceAllBtn) return;

              const searchTerm = fileFindInput.value;
              modalSearchMatches = [];
              modalCurrentMatchIndex = -1;
              fileMatchCountSpan.textContent = '';

               // Clear existing highlights first based on current contenteditable HTML
              clearFileHighlights();

              if (!searchTerm) {
                  fileFindNextBtn.disabled = true;
                  fileReplaceNextBtn.disabled = true;
                  fileReplaceAllBtn.disabled = true;
                  return;
              }

              // Get the raw text content from the editable pre element
              const textContent = fileContentModalPreElement.textContent;
              if (!textContent) return;

              const searchTermEscaped = escapeRegExp(searchTerm);
              let regex;
              try {
                  regex = new RegExp(searchTermEscaped, 'gi'); // Case-insensitive, global
              } catch (e) {
                  console.error("Invalid search term regex:", e);
                  fileMatchCountSpan.textContent = 'L·ªói c√∫ ph√°p t√¨m ki·∫øm';
                  fileFindNextBtn.disabled = true; fileReplaceNextBtn.disabled = true; fileReplaceAllBtn.disabled = true;
                  return;
              }


              let match;
              while ((match = regex.exec(textContent)) !== null) {
                   modalSearchMatches.push({ start: match.index, end: match.index + match[0].length });
              }

              fileMatchCountSpan.textContent = modalSearchMatches.length > 0 ? `(${modalSearchMatches.length})` : '(0)';

              if (modalSearchMatches.length > 0) {
                   fileFindNextBtn.disabled = false;
                   fileReplaceInput.disabled = false;
                   fileReplaceNextBtn.disabled = false;
                   fileReplaceAllBtn.disabled = false;
                   highlightFileMatch(0); // Highlight the first match
              } else {
                   fileFindNextBtn.disabled = true;
                   fileReplaceInput.disabled = true;
                   fileReplaceNextBtn.disabled = true;
                   fileReplaceAllBtn.disabled = true;
              }
         }

         // MODIFICATION: Navigate and highlight next match
         function findNextFileMatch() {
              if (modalSearchMatches.length === 0) return;

              modalCurrentMatchIndex = (modalCurrentMatchIndex + 1) % modalSearchMatches.length;
              highlightFileMatch(modalCurrentMatchIndex);
         }

         // MODIFICATION: Highlight a specific match by index (Revised)
         function highlightFileMatch(index) {
              if (!fileContentModalPreElement || !modalSearchMatches || index < 0 || index >= modalSearchMatches.length) {
                  console.error("Invalid state for highlighting.");
                  return;
              }
              // Save current cursor position before modifying innerHTML
              const selection = window.getSelection();
              const range = selection.getRangeAt(0);
              const preElement = fileContentModalPreElement;
              const textNode = preElement.firstChild; // Assuming simple text content

              let savedStart = range.startOffset;
              let savedEnd = range.endOffset;
               if (textNode && textNode.nodeType !== Node.TEXT_NODE) { // Handle complex cases or empty
                    savedStart = savedEnd = 0;
               }


              clearFileHighlights(); // Clear previous highlights without affecting original text

              const match = modalSearchMatches[index];
              const textContent = fileContentModalPreElement.textContent; // Use current text content

              let html = '';
              let lastIndex = 0;

              modalSearchMatches.forEach((m, i) => {
                  html += escapeHtml(textContent.substring(lastIndex, m.start));
                  const spanClass = (i === index) ? 'highlight current' : 'highlight';
                  html += `<span class="${spanClass}">${escapeHtml(textContent.substring(m.start, m.end))}</span>`;
                  lastIndex = m.end;
              });
              html += escapeHtml(textContent.substring(lastIndex));

              // Temporarily turn off contenteditable while setting innerHTML
              const isEditable = preElement.getAttribute('contenteditable') === 'true';
              preElement.setAttribute('contenteditable', 'false');
              preElement.innerHTML = html;
               if(isEditable) preElement.setAttribute('contenteditable', 'true'); // Restore


              // Restore cursor position (simplified - may not be exact with complex HTML)
              if (textNode) { // Check if textNode still exists after innerHTML change
                  const newTextNode = preElement.firstChild;
                   if (newTextNode && newTextNode.nodeType === Node.TEXT_NODE) {
                       const newRange = document.createRange();
                       newRange.setStart(newTextNode, Math.min(savedStart, newTextNode.length));
                       newRange.setEnd(newTextNode, Math.min(savedEnd, newTextNode.length));
                       selection.removeAllRanges();
                       selection.addRange(newRange);
                   }
              }


              // Scroll the current highlighted match into view
              const currentHighlightElement = fileContentModalPreElement.querySelector('.highlight.current');
              if (currentHighlightElement) {
                  setTimeout(() => {
                      currentHighlightElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  }, 10);
              }
         }

         // MODIFICATION: Clear all highlights (Revised)
         function clearFileHighlights() {
              if (!fileContentModalPreElement) return;
               // Get the raw text content
               const text = fileContentModalPreElement.textContent;
               // Set textContent back to remove all HTML tags (including highlights)
               fileContentModalPreElement.textContent = text;
               // Restore contentEditable state if needed (it shouldn't be lost by textContent, but safety)
               fileContentModalPreElement.setAttribute('contenteditable', 'true');
         }


         // MODIFICATION: Replace next match
         function replaceNextFileMatch() {
              if (modalSearchMatches.length === 0 || modalCurrentMatchIndex === -1 || !fileContentModalPreElement || !fileReplaceInput) return;

              const replaceTerm = fileReplaceInput.value;
              const match = modalSearchMatches[modalCurrentMatchIndex];

              // Get the current text content from the editable pre element
              let textContent = fileContentModalPreElement.textContent;

              // Perform replacement on the raw text string
              const newText = textContent.substring(0, match.start) + replaceTerm + textContent.substring(match.end);

              // Update the pre element's text content (removes highlights)
              fileContentModalPreElement.textContent = newText;

               // Update original content tracker so save button state is correct
               modalOriginalFileContent = fileContentModalPreElement.textContent;
               checkFileModalContentChanged();

              // Re-run find to update matches and highlighting based on the new text
              // This will automatically reset modalCurrentMatchIndex to 0 and highlight the first new match
              findInFileContent();

              Swal.fire('ƒê√£ thay th·∫ø', 'M·ª•c ƒëang ch·ªçn ƒë√£ ƒë∆∞·ª£c thay th·∫ø. Vui l√≤ng nh·∫•n "T√¨m ti·∫øp" ƒë·ªÉ ƒë·∫øn m·ª•c ti·∫øp theo.', 'success');
         }

         // MODIFICATION: Replace all matches
         function replaceAllFileMatches() {
              if (modalSearchMatches.length === 0 || !fileContentModalPreElement || !fileReplaceInput || !fileFindInput) {
                  Swal.fire('Kh√¥ng c√≥ g√¨ ƒë·ªÉ thay th·∫ø', '', 'info');
                  return;
              }

              const replaceTerm = fileReplaceInput.value;
              const searchTerm = fileFindInput.value;

              if (!searchTerm) { // Can't replace if nothing is being searched
                   Swal.fire('L·ªói', 'Vui l√≤ng nh·∫≠p n·ªôi dung c·∫ßn t√¨m tr∆∞·ªõc khi thay th·∫ø.', 'warning');
                   return;
              }

              const originalText = fileContentModalPreElement.textContent;

              let newText = originalText;
              try {
                  const regex = new RegExp(escapeRegExp(searchTerm), 'gi');
                  newText = originalText.replace(regex, replaceTerm);
              } catch (e) {
                   console.error("Invalid search term regex for replace:", e);
                   Swal.fire('L·ªói', 'L·ªói c√∫ ph√°p t√¨m ki·∫øm kh√¥ng h·ª£p l·ªá ƒë·ªÉ thay th·∫ø.', 'error');
                   return;
              }


              if (newText === originalText) {
                  Swal.fire('Kh√¥ng c√≥ g√¨ ƒë·ªÉ thay th·∫ø', 'Kh√¥ng t√¨m th·∫•y vƒÉn b·∫£n c·∫ßn thay th·∫ø.', 'info');
                  return;
              }

              Swal.fire({
                  title: 'Thay th·∫ø t·∫•t c·∫£?',
                  text: `Thao t√°c n√†y s·∫Ω thay th·∫ø t·∫•t c·∫£ ${modalSearchMatches.length} l·∫ßn xu·∫•t hi·ªán c·ªßa "${escapeHtml(searchTerm)}" b·∫±ng "${escapeHtml(replaceTerm)}".`,
                  icon: 'warning',
                  showCancelButton: true,
                  confirmButtonColor: '#d33',
                  confirmButtonText: 'V√¢ng, thay th·∫ø!'
              }).then((result) => {
                  if (result.isConfirmed) {
                      // Update the pre element's text content (removes highlights)
                      fileContentModalPreElement.textContent = newText;

                       // Update original content tracker
                       modalOriginalFileContent = fileContentModalPreElement.textContent;
                       checkFileModalContentChanged(); // Re-check save button state

                      // Clear search state after replacing all
                      modalSearchMatches = [];
                      modalCurrentMatchIndex = -1;
                      fileMatchCountSpan.textContent = '';
                      fileFindNextBtn.disabled = true;
                       // Keep replace inputs/buttons enabled if user wants to search again

                      Swal.fire('ƒê√£ thay th·∫ø!', 'T·∫•t c·∫£ c√°c m·ª•c ƒë√£ ƒë∆∞·ª£c thay th·∫ø.', 'success');
                  }
              });
         }


        // --- Duplicate Finding Logic ---

        // MODIFICATION: Function to extract comparison part from block
        function extractComparisonPart(blockContent) {
            if (typeof blockContent !== 'string') return '';

            // Find the position of \loigiai, \loigiai*, etc., case-insensitive
            const match = blockContent.match(/\\loigiai\s*[*]?\s*$/mi); // Match \loigiai followed by optional * and optional spaces at the end of a line/block

            if (match) {
                // Return content from the beginning up to the start of the \loigiai match
                return blockContent.substring(0, match.index).trim();
            } else {
                // If \loigiai is not found, compare the whole block content (after trimming)
                return blockContent.trim();
            }
        }

        // MODIFICATION: Function to find duplicate blocks (exact match after extraction)
        async function findDuplicates() {
            showLoading(true, "ƒêang t√¨m c√¢u tr√πng l·∫∑p...");

            const allBlocksForComparison = [];
            let fetchPromises = [];

            // 1. Gather all blocks and their comparison parts
            for (const id in rawData) { // Iterate through the FILTERED rawData
                if (!Object.prototype.hasOwnProperty.call(rawData, id)) continue;
                const item = rawData[id];
                if (!item || item.stats?.choice + item.stats?.choiceTF + item.stats?.other === 0) continue; // Skip IDs with no blocks

                if (item.exList === null) {
                    // If exList is not loaded, schedule fetch
                    fetchPromises.push(fetchExListIfNeeded(id));
                } else {
                    // If exList is already loaded, process it
                    item.exList.forEach((blockContent, index) => {
                         const comparisonPart = extractComparisonPart(blockContent);
                         if (comparisonPart) { // Only include blocks with non-empty comparison parts
                             allBlocksForComparison.push({
                                 id: id,
                                 index: index,
                                 content: blockContent, // Store full content
                                 comparisonPart: comparisonPart
                             });
                         }
                    });
                }
            }

            // 2. Fetch exLists for IDs that weren't loaded
             if (fetchPromises.length > 0) {
                 console.log(`Fetching ${fetchPromises.length} exLists for duplicate check...`);
                 try {
                     await Promise.all(fetchPromises); // fetchExListIfNeeded updates rawData in place
                      // Now that fetch is complete, re-iterate rawData to process fetched lists
                      for (const id in rawData) {
                           if (!Object.prototype.hasOwnProperty.call(rawData, id)) continue;
                           const item = rawData[id];
                            // Check if exList was just loaded (or was already loaded) and not null
                           if (item && Array.isArray(item.exList) && item.exList.length > 0) {
                                item.exList.forEach((blockContent, index) => {
                                    // Avoid adding duplicates if the ID was processed in the first pass
                                    const alreadyAdded = allBlocksForComparison.some(b => b.id === id && b.index === index);
                                     if (!alreadyAdded) {
                                         const comparisonPart = extractComparisonPart(blockContent);
                                          if (comparisonPart) {
                                             allBlocksForComparison.push({
                                                 id: id,
                                                 index: index,
                                                 content: blockContent,
                                                 comparisonPart: comparisonPart
                                             });
                                          }
                                     }
                                });
                           }
                      }
                 } catch (fetchError) {
                     console.error("Error fetching exLists for duplicate check:", fetchError);
                     showLoading(false);
                     Swal.fire('L·ªói T·∫£i D·ªØ Li·ªáu', 'Kh√¥ng th·ªÉ t·∫£i ƒë·∫ßy ƒë·ªß n·ªôi dung c√¢u h·ªèi ƒë·ªÉ t√¨m tr√πng l·∫∑p.', 'error');
                     return; // Stop if fetch fails
                 }
             }


            // 3. Group blocks by exact comparison part
            const duplicateGroupsMap = new Map(); // Map<string, Array<{id, index, content}>>

            allBlocksForComparison.forEach(block => {
                const key = block.comparisonPart; // Use the extracted part as the key
                if (!duplicateGroupsMap.has(key)) {
                    duplicateGroupsMap.set(key, []);
                }
                duplicateGroupsMap.get(key).push({
                    id: block.id,
                    index: block.index,
                    content: block.content // Store full content
                });
            });

            // 4. Filter for groups with more than one block
            const duplicateGroups = Array.from(duplicateGroupsMap.values()).filter(group => group.length > 1);

            console.log(`T√¨m th·∫•y ${duplicateGroups.length} nh√≥m c√¢u tr√πng l·∫∑p.`);

            showLoading(false);

            if (duplicateGroups.length > 0) {
                 renderDuplicateResults(duplicateGroups);
                 Swal.fire('Ho√†n th√†nh', `T√¨m th·∫•y ${duplicateGroups.length} nh√≥m c√¢u tr√πng l·∫∑p.`, 'success');
            } else {
                 Swal.fire('Kh√¥ng t√¨m th·∫•y c√¢u tr√πng l·∫∑p', '', 'info');
                 // Ensure duplicate results area is hidden if shown previously
                 if(duplicateResultsArea) duplicateResultsArea.classList.add('d-none');
            }
         }

         // MODIFICATION: Render duplicate results
         function renderDuplicateResults(duplicateGroups) {
             if (!duplicateResultsArea || !duplicateGroupsContainer || !duplicateActionsDiv) return;

             duplicateGroupsContainer.innerHTML = ''; // Clear previous results

             if (duplicateGroups.length === 0) {
                 duplicateResultsArea.classList.add('d-none');
                 return;
             }

             duplicateResultsArea.classList.remove('d-none'); // Show the results area
             duplicateActionsDiv.classList.remove('d-none'); // Show action buttons

             duplicateGroups.forEach((group, groupIndex) => {
                 const groupDiv = document.createElement('div');
                 groupDiv.className = 'duplicate-group';

                 const header = document.createElement('div');
                 header.className = 'duplicate-group-header';
                 header.textContent = `Nh√≥m ${groupIndex + 1} (${group.length} b·∫£n sao)`;
                 header.addEventListener('click', () => groupDiv.classList.toggle('open')); // Toggle expand/collapse

                 groupDiv.appendChild(header);

                 const blocksContainer = document.createElement('div');
                 blocksContainer.className = 'duplicate-group-blocks'; // Initially hidden

                 // Add "Ch·ªçn t·∫•t c·∫£/B·ªè ch·ªçn t·∫•t c·∫£" for the group
                 const selectAllDiv = document.createElement('div');
                 selectAllDiv.className = 'form-check form-check-inline duplicate-actions mb-2';
                 const selectAllCheckbox = document.createElement('input');
                 selectAllCheckbox.type = 'checkbox';
                 selectAllCheckbox.className = 'form-check-input';
                 const selectAllLabel = document.createElement('label');
                 selectAllLabel.className = 'form-check-label';
                 selectAllLabel.textContent = 'Ch·ªçn/B·ªè ch·ªçn t·∫•t c·∫£ trong nh√≥m n√†y';
                 selectAllCheckbox.addEventListener('change', () => {
                      blocksContainer.querySelectorAll('.duplicate-block-item input[type="checkbox"]').forEach(checkbox => {
                           checkbox.checked = selectAllCheckbox.checked;
                      });
                 });
                 selectAllDiv.appendChild(selectAllCheckbox);
                 selectAllDiv.appendChild(selectAllLabel);
                 blocksContainer.appendChild(selectAllDiv);


                 group.forEach((block, blockIndex) => {
                     const blockItemDiv = document.createElement('div');
                     blockItemDiv.className = 'duplicate-block-item';

                     const checkbox = document.createElement('input');
                     checkbox.type = 'checkbox';
                     checkbox.className = 'form-check-input';
                     // Add data attributes to identify the block
                     checkbox.dataset.id = block.id;
                     checkbox.dataset.index = block.index;

                     const infoSpan = document.createElement('span');
                     infoSpan.innerHTML = `<b>ID: ${escapeHtml(block.id)}</b> (Block ${blockIndex + 1})`;

                     const pre = document.createElement('pre');
                     pre.textContent = block.content; // Display full content

                     blockItemDiv.appendChild(checkbox);
                     blockItemDiv.appendChild(infoSpan);
                     blockItemDiv.appendChild(pre); // Append pre after info

                     blocksContainer.appendChild(blockItemDiv);
                 });

                 groupDiv.appendChild(blocksContainer);
                 duplicateGroupsContainer.appendChild(groupDiv);
             });

             // Scroll the duplicate results area into view
             duplicateResultsArea.scrollIntoView({ behavior: 'smooth', block: 'start' });

             // Add listener for the main delete button
             document.getElementById('deleteSelectedDuplicatesBtn')?.removeEventListener('click', deleteSelectedDuplicates); // Prevent multiple listeners
             document.getElementById('deleteSelectedDuplicatesBtn')?.addEventListener('click', deleteSelectedDuplicates);
             document.getElementById('closeDuplicateResultsBtn')?.removeEventListener('click', closeDuplicateResults); // Prevent multiple listeners
             document.getElementById('closeDuplicateResultsBtn')?.addEventListener('click', closeDuplicateResults);
         }

        // MODIFICATION: Delete selected duplicate blocks
        async function deleteSelectedDuplicates() {
             const checkboxes = duplicateGroupsContainer.querySelectorAll('.duplicate-block-item input[type="checkbox"]:checked');
             if (checkboxes.length === 0) {
                 Swal.fire('Ch∆∞a ch·ªçn c√¢u n√†o ƒë·ªÉ x√≥a', '', 'info');
                 return;
             }

             Swal.fire({
                 title: 'X√≥a c√°c c√¢u ƒë√£ ch·ªçn?',
                 text: `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ${checkboxes.length} block ƒë√£ ch·ªçn? Thao t√°c n√†y kh√¥ng th·ªÉ ho√†n t√°c.`,
                 icon: 'warning',
                 showCancelButton: true,
                 confirmButtonColor: '#d33',
                 confirmButtonText: 'V√¢ng, x√≥a!'
             }).then(async (result) => {
                 if (result.isConfirmed) {
                     showLoading(true, `ƒêang x√≥a ${checkboxes.length} block...`);

                     const blocksToDelete = Array.from(checkboxes).map(cb => ({
                         id: cb.dataset.id,
                         index: parseInt(cb.dataset.index)
                     }));

                      // Group blocks to delete by ID
                     const blocksToDeleteById = blocksToDelete.reduce((acc, block) => {
                          if (!acc[block.id]) acc[block.id] = [];
                          acc[block.id].push(block.index);
                          return acc;
                     }, {});

                      let deletedCount = 0;
                      let idsPossiblyEmpty = [];

                     try {
                          if (!db) await initDB();
                          const tx = db.transaction(QUESTION_STORE_NAME, 'readwrite');
                          const store = tx.objectStore(QUESTION_STORE_NAME);

                          const idDeletionPromises = Object.keys(blocksToDeleteById).map(id => {
                               return new Promise((resolve, reject) => {
                                    // Fetch the current record from DB to ensure we have the latest exList
                                   const getRequest = store.get(id);
                                   getRequest.onsuccess = (event) => {
                                       const record = event.target.result;
                                       if (!record || !Array.isArray(record.exList)) {
                                            console.warn(`Record or exList not found for ID ${id} during deletion.`);
                                            resolve(); // Skip this ID if data is missing
                                            return;
                                        }

                                        const indicesToDelete = new Set(blocksToDeleteById[id]);
                                        const newExList = record.exList.filter((_, index) => !indicesToDelete.has(index));

                                        if (newExList.length === record.exList.length) {
                                            console.warn(`No blocks deleted for ID ${id}. Indices to delete:`, indicesToDelete, 'Current exList length:', record.exList.length);
                                            resolve(); // No changes needed for this ID
                                            return;
                                        }

                                        const blocksActuallyDeleted = record.exList.length - newExList.length;
                                        deletedCount += blocksActuallyDeleted;

                                        if (newExList.length === 0) {
                                             // If no blocks left, mark the ID for full deletion from rawData and UI
                                             idsPossiblyEmpty.push(id);
                                             // Delete from DB
                                             const deleteRequest = store.delete(id);
                                              deleteRequest.onsuccess = resolve;
                                              deleteRequest.onerror = reject;
                                        } else {
                                             // If blocks remain, update the record in DB
                                            record.exList = newExList;
                                            record.stats = classifyEx(newExList); // Recalculate stats

                                            const putRequest = store.put(record);
                                            putRequest.onsuccess = resolve;
                                            putRequest.onerror = reject;
                                        }
                                   };
                                    getRequest.onerror = reject; // Reject if get fails
                               });
                          });

                          // Wait for all DB operations to complete
                          await Promise.all(idDeletionPromises);
                          await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; }); // Wait for transaction

                          // Update in-memory rawData and UI *after* successful DB updates
                           idsPossiblyEmpty.forEach(id => {
                                if(rawData[id]) delete rawData[id]; // Remove from filtered rawData
                           });

                           // For IDs where blocks were deleted but not the whole ID, we need to update rawData
                           Object.keys(blocksToDeleteById).filter(id => !idsPossiblyEmpty.includes(id)).forEach(id => {
                                if (rawData[id]) {
                                     // We need the *updated* record from DB to reflect changes accurately in rawData
                                     // Re-fetching here might be slow. A simpler way is to trust the DB update
                                     // and reload data/render *after* the whole batch.
                                     // Or, update rawData directly based on newExList logic. Let's try reloading.
                                }
                           });


                         // Reload all data and re-render the entire UI
                         await loadAllDataAndRenderUI();

                         Swal.fire('ƒê√£ x√≥a!', `ƒê√£ x√≥a th√†nh c√¥ng ${deletedCount} block tr√πng l·∫∑p.`, 'success');

                     } catch (error) {
                          console.error("Error deleting duplicates:", error);
                         Swal.fire('L·ªói X√≥a', `Kh√¥ng th·ªÉ x√≥a c√°c block ƒë√£ ch·ªçn: ${error?.message || error}`, 'error');
                         // Attempt to reload data even on error to show current state
                         loadAllDataAndRenderUI();
                     } finally {
                         showLoading(false);
                         // Clear duplicate results area after deletion attempt
                         closeDuplicateResults();
                     }
                 }
             });
         }

        // MODIFICATION: Close duplicate results area
        function closeDuplicateResults() {
             if (duplicateResultsArea) duplicateResultsArea.classList.add('d-none');
             if (duplicateGroupsContainer) duplicateGroupsContainer.innerHTML = '';
             if (duplicateActionsDiv) duplicateActionsDiv.classList.add('d-none');
         }


        // MODIFICATION: Orchestrates initial data load and UI rendering
        async function loadAllDataAndRenderUI() {
            showLoading(true, "ƒêang t·∫£i d·ªØ li·ªáu t·ª´ cache c·ª•c b·ªô...");
            const menuDiv = document.getElementById("menu");
             infoMessageDiv = document.getElementById('infoMessage');

            if(initialMessageDiv) initialMessageDiv.style.display = 'none';
            if(infoMessageDiv) infoMessageDiv.classList.add('d-none');
            if (menuDiv) {
                 const infoMsgHtml = infoMessageDiv ? infoMessageDiv.outerHTML : '';
                 menuDiv.innerHTML = infoMsgHtml;
                 menuDiv.style.display = 'none';
            } else {
                 console.error("#menu div not found!");
            }

            try {
                 if (Object.keys(globalPredefinedIdMap).length === 0) { await loadPredefinedIdMap_Client(); }

                // Load ALL question data from DB first
                const allDataFromDB = await loadQuestionDataFromDB();
                 totalDbQuestionCount = Object.keys(allDataFromDB).length; // Count reflects total in DB

                // Load file data from DB (already filtered by prefix)
                loadedFiles = await loadFileDataFromDB();
                 totalDbFileCount = loadedFiles.length; // Count reflects files after exclusion filter

                // Apply bank.json filter to the loaded question data to populate rawData
                rawData = {};
                let filteredIdCount = 0;
                const bankMapLoaded = Object.keys(globalPredefinedIdMap).length > 0;

                if (!bankMapLoaded) {
                    console.warn("bank.json map is empty. Loading ALL IDs from DB into rawData.");
                    Object.assign(rawData, allDataFromDB); // Use all data if bank.json not loaded
                    filteredIdCount = totalDbQuestionCount;
                } else {
                     // Filter data based on bank.json keys
                    for (const id in allDataFromDB) {
                        if (Object.prototype.hasOwnProperty.call(allDataFromDB, id)) {
                            if (globalPredefinedIdMap.hasOwnProperty(id)) {
                                rawData[id] = allDataFromDB[id]; // Keep this item for display
                                filteredIdCount++;
                            }
                        }
                    }
                }

                console.log(`ƒê√£ t·∫£i ${totalDbQuestionCount} ID v√† ${totalDbFileCount} file t·ª´ cache.`);
                console.log(`Hi·ªÉn th·ªã ${filteredIdCount} ID kh·ªõp v·ªõi bank.json (ch·∫ø ƒë·ªô ID).`);


                // Apply predefined descriptions to the FILTERED rawData
                for (const id in rawData) {
                    const predefinedDesc = getPredefinedDescById(id);
                    if (predefinedDesc && predefinedDesc !== rawData[id].desc) {
                         rawData[id].desc = predefinedDesc;
                    }
                     // Ensure stats are calculated for the filtered rawData (based on full exList if available)
                     if (!rawData[id].stats || (rawData[id].exList && (rawData[id].stats.choice + rawData[id].stats.choiceTF + rawData[id].stats.other === 0))) {
                          rawData[id].stats = classifyEx(rawData[id].exList || []);
                     }
                }

                const hasQuestions = Object.keys(rawData).length > 0; // Check filtered questions
                const hasFiles = loadedFiles.length > 0; // Check loaded files (after prefix filter)

                if (hasQuestions || hasFiles) {
                    if (menuDiv) menuDiv.style.display = 'block';

                    if(infoMessageDiv) {
                         const totalFilteredIDCount = Object.keys(rawData).length;

                         if (bankMapLoaded) {
                             infoMessageDiv.textContent = ``;//ƒê√£ t·∫£i ${totalDbQuestionCount} ID (hi·ªÉn th·ªã ${totalFilteredIDCount} kh·ªõp bank.json) v√† ${totalDbFileCount} file (sau l·ªçc ti·ªÅn t·ªë) t·ª´ cache.
                         } else {
                              infoMessageDiv.textContent = `L∆∞u √Ω: bank.json kh√¥ng t·∫£i ƒë∆∞·ª£c ho·∫∑c tr·ªëng. ƒê√£ t·∫£i ${totalDbQuestionCount} ID v√† ${totalDbFileCount} file (sau l·ªçc ti·ªÅn t·ªë) t·ª´ cache.`;
                         }
                         infoMessageDiv.classList.remove('d-none');
                    }

                    const viewModeSelector = document.getElementById('viewModeSelector');
                    const initialMode = viewModeSelector ? viewModeSelector.value : 'id-tree';
                    renderMenu(initialMode); // Render based on selected mode

                } else {
                    if (menuDiv) { menuDiv.innerHTML = ""; menuDiv.style.display = 'none'; }
                    if (initialMessageDiv) initialMessageDiv.style.display = 'block';
                    if (infoMessageDiv) infoMessageDiv.classList.add('d-none');
                }

                updateSelectedIDsTable();

            } catch (error) {
                console.error("L·ªói khi t·∫£i v√† render d·ªØ li·ªáu t·ª´ DB:", error);
                handleDBError(error);
            } finally {
                showLoading(false);
            }
        }

        // --- Initialization ---
        async function initializeApp() {
             loadingOverlay = document.getElementById('loadingOverlay');
             loadingTextElement = document.getElementById('loadingText');
             initialMessageDiv = document.getElementById('initialMessage');
             infoMessageDiv = document.getElementById('infoMessage');
             duplicateResultsArea = document.getElementById('duplicateResultsArea'); // Get duplicate results area
             duplicateGroupsContainer = document.getElementById('duplicateGroupsContainer'); // Get container
             duplicateActionsDiv = document.getElementById('duplicateActions'); // Get actions div


             fileContentModalPreElement = document.getElementById('fileContentModalPre');
             copyFileContentBtnElement = document.getElementById('copyFileContentBtn');
             saveFileContentBtnElement = document.getElementById('saveFileContentBtn');
             fileFindInput = document.getElementById('fileFindInput');
             fileFindNextBtn = document.getElementById('fileFindNextBtn');
             fileReplaceInput = document.getElementById('fileReplaceInput');
             fileReplaceNextBtn = document.getElementById('fileReplaceNextBtn');
             fileReplaceAllBtn = document.getElementById('fileReplaceAllBtn');
             fileMatchCountSpan = document.getElementById('fileMatchCount');


             console.log("DOM Loaded. Starting async initialization...");
             showLoading(true, 'ƒêang kh·ªüi t·∫°o...');

             debouncedRenderFileBrowser = debounce(renderMenu.bind(null, 'file-browser'), 350);
             debouncedRenderMenu = debounce(renderMenu.bind(null, document.getElementById('viewModeSelector')?.value || 'id-tree'), 350);


             try {
                  await loadPredefinedIdMap_Client();
                  await initDB();
                  await loadAllDataAndRenderUI();

                  console.log("Finished initial data load and render.");
             } catch (error) {
                  console.error("Initialization failed:", error);
                  showLoading(false);
                  if (!document.querySelector('.swal2-container')) {
                       Swal.fire({ icon: 'error', title: 'L·ªói Kh·ªüi T·∫°o', text: `L·ªói: ${error?.message || error}` });
                  }
                 if(initialMessageDiv) initialMessageDiv.style.display = 'block';
                 if(document.getElementById("menu")) document.getElementById("menu").style.display = 'none';
                 if(infoMessageDiv) infoMessageDiv.classList.add('d-none');
             }
         }


        document.addEventListener('DOMContentLoaded', async () => {

            const safeAddListener = (id, event, handler) => { const el = document.getElementById(id); if (el) { el.addEventListener(event, handler); } else { console.warn(`Element "${id}" not found.`); } };
            safeAddListener('addLocalFoldersBtn', 'click', () => document.getElementById('folderInput')?.click());
            safeAddListener('folderInput', 'change', handleFolderSelection);
            safeAddListener('downloadDataBtn', 'click', downloadData);
            safeAddListener('uploadDataBtn', 'click', () => document.getElementById('uploadFileInput')?.click());
            safeAddListener('uploadFileInput', 'change', handleUploadSelection);
            safeAddListener('clearLocalCacheBtn', 'click', clearLocalCache);
            safeAddListener('generateExamsBtn', 'click', generateMultipleExams);
            safeAddListener('clearSelectionsBtn', 'click', clearSelections);
            safeAddListener('clearGrabbedBtn', 'click', clearGrabbedContent);
            safeAddListener('copyAllGrabbedBtn', 'click', copyAllGrabbedContent);
            safeAddListener('saveEditBtn', 'click', saveEdit);

            safeAddListener('viewModeSelector', 'change', (event) => renderMenu(event.target.value));

            safeAddListener('searchBox', 'input', () => { currentRenderMode = 'search'; debouncedRenderMenu(); });
            safeAddListener('typeFilter', 'change', () => { currentRenderMode = 'id-tree'; renderMenu('id-tree'); });
            safeAddListener('clearSearchBtn', 'click', clearSearch);
            safeAddListener('expandAllBtn', 'click', () => toggleAll(true));
            safeAddListener('collapseAllBtn', 'click', () => toggleAll(false));

            safeAddListener('fileSearchBox', 'input', () => { debouncedRenderFileBrowser(); });
            safeAddListener('expandAllFilesBtn', 'click', () => toggleAll(true));
            safeAddListener('collapseAllFilesBtn', 'click', () => toggleAll(false));
            safeAddListener('fileViewControls', 'click', (event) => { event.stopPropagation(); });

            safeAddListener('findDuplicatesBtn', 'click', findDuplicates); // MODIFICATION: Listener for Find Duplicates button

             const fileContentModalElement = document.getElementById('fileContentModal');
             if(fileContentModalElement){
                  fileContentModalElement.addEventListener('hidden.bs.modal', () => {
                       modalSearchMatches = [];
                       modalCurrentMatchIndex = -1;
                       if(fileFindInput) fileFindInput.value = '';
                       if(fileReplaceInput) fileReplaceInput.value = '';
                       if(fileMatchCountSpan) fileMatchCountSpan.textContent = '';
                       if(fileContentModalPreElement) fileContentModalPreElement.textContent = '';
                       modalOriginalFileContent = null;
                       modalCurrentFilePath = null;

                       if(copyFileContentBtnElement) { copyFileContentBtnElement.disabled = true; copyFileContentBtnElement.innerHTML = '<i class="bi bi-clipboard"></i> Copy n·ªôi dung file'; }
                       if(saveFileContentBtnElement) saveFileContentBtnElement.disabled = true;
                       if(fileFindInput) fileFindInput.disabled = true;
                       if(fileFindNextBtn) fileFindNextBtn.disabled = true;
                       if(fileReplaceInput) fileReplaceInput.disabled = true;
                       if(fileReplaceNextBtn) fileReplaceNextBtn.disabled = true;
                       if(fileReplaceAllBtn) fileReplaceAllBtn.disabled = true;

                       if(fileContentModalPreElement) fileContentModalPreElement.setAttribute('contenteditable', 'false');
                  });
             }

             safeAddListener('copyFileContentBtn', 'click', () => {
                  if (!fileContentModalPreElement || !copyFileContentBtnElement) return;
                  const content = fileContentModalPreElement.textContent;
                  if (!content) {
                       Swal.fire('Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ copy', '', 'info');
                       return;
                  }
                  if (copyFileContentBtnElement.classList.contains('copied-success')) { return; }

                  navigator.clipboard.writeText(content).then(() => {
                       const originalHTML = copyFileContentBtnElement.innerHTML;
                       copyFileContentBtnElement.innerHTML = '<i class="bi bi-check-lg"></i> ƒê√£ copy!';
                       copyFileContentBtnElement.classList.add('copied-success');
                       setTimeout(() => {
                            if (document.body.contains(copyFileContentBtnElement)) {
                                 copyFileContentBtnElement.innerHTML = originalHTML;
                                 copyFileContentBtnElement.classList.remove('copied-success');
                            }
                       }, 1500);
                  }).catch(err => {
                       console.error('Copy failed:', err);
                       Swal.fire('L·ªói Copy', 'Kh√¥ng th·ªÉ copy n·ªôi dung file.', 'error');
                  });
             });

             safeAddListener('saveFileContentBtn', 'click', saveFileContent);

             if(fileFindInput) {
                  fileFindInput.addEventListener('input', debounce(findInFileContent, 300));
             }
             if(fileFindNextBtn) {
                  fileFindNextBtn.addEventListener('click', findNextFileMatch);
             }
             if(fileReplaceNextBtn) {
                  fileReplaceNextBtn.addEventListener('click', replaceNextFileMatch);
             }
             if(fileReplaceAllBtn) {
                  fileReplaceAllBtn.addEventListener('click', replaceAllFileMatches);
             }


            addFileViewListeners();

            initializeApp();

        });

        // --- Global Error Handlers ---
        window.onerror = function(message, source, lineno, colno, error) { console.error("Uncaught Error:", { message, source, lineno, colno, errorObj: error }); showLoading(false); if (!document.querySelector('.swal2-container') || !document.querySelector('.swal2-icon-error')) { Swal.fire({ icon: 'error', title: 'L·ªói B·∫•t Ng·ªù', text: '...', footer: `<small>${escapeHtml(message)} at ${escapeHtml(source)}:${lineno}</small>` }); } return true; };
        window.onunhandledrejection = function(event) { console.error("Unhandled Promise Rejection:", event.reason); showLoading(false); if (!document.querySelector('.swal2-container') || !document.querySelector('.swal2-icon-error')) { Swal.fire({ icon: 'error', title: 'L·ªói B·∫•t ƒê·ªìng B·ªô', text: '...', footer: `<small>${escapeHtml(event.reason?.message || event.reason || 'Kh√¥ng r√µ l·ªói')}</small>` }); } };

    </script>
    <!-- Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <!-- SweetAlert2 JS -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.all.min.js"></script>
</body>
</html>